import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class DefenseTowerIntern {
    private static BufferedReader reader = null;
    public static int N; //  количество платформ, находящееся в башне
    public static int M; // количество добровольцев


    private static void init() {
        reader = new BufferedReader(new InputStreamReader(System.in));
    }

    public static void main(String[] args) throws Exception {
        init();
        run();
    }

    private static void run() throws IOException {
        StringTokenizer stringTokenizer = new StringTokenizer(reader.readLine());
        N = Integer.parseInt(stringTokenizer.nextToken());
        M = Integer.parseInt(stringTokenizer.nextToken());

        Map<Integer, Integer> platforms = new HashMap<>();
        Map<Integer, Integer> platformsClear = new HashMap<>();
        Map<Integer, Integer> volunteers = new HashMap<>();
        String[] arg = reader.readLine().split(" ");
        for (int i = 0; i < N; i++) {
            int lengthPlatform = Integer.parseInt(arg[i]);
            platforms.put(i, lengthPlatform);
            platformsClear.put(i, lengthPlatform);
        }
        arg = reader.readLine().split(" ");
        for (int i = 0; i < M; i++) {
            int length = Integer.parseInt(arg[i]);
            volunteers.put(i, length);
        }
        // 7 3 4 2 2
        int prev = -1;
        for (Map.Entry<Integer, Integer> entry : platforms.entrySet()) {
            if (prev == -1) {
                prev = 0;
                continue;
            }
            int lengthCurrent = entry.getValue();
            int lengthPrev = platforms.get(prev);
            if (lengthCurrent >= lengthPrev) {
                platformsClear.remove(prev);
            }
            prev = entry.getKey();
        }
        // 7 4 2
        Map<Integer, Integer> sortedVolunteers = sortByValue(volunteers);
        int count = 0;
        int defPrev = -1;

        Map<Integer, Integer> reversePlatform = sortByValueReverse(platformsClear);
        // 2 4 7
        for (Map.Entry<Integer, Integer> entry : reversePlatform.entrySet()) {
            int lengthCurrent;
            int lengthPrev;
            if (defPrev == -1) {
                defPrev = entry.getKey();
                lengthCurrent = entry.getValue();
                for (Map.Entry<Integer, Integer> def : sortedVolunteers.entrySet()) {
                    if (def.getValue() <= lengthCurrent) {
                        count++;
                        sortedVolunteers.remove(def.getKey());
                        break;
                    }
                }
                continue;
            }
            lengthCurrent = entry.getValue();
            lengthPrev = reversePlatform.get(defPrev);
            int dif = lengthCurrent - lengthPrev;
            for (Map.Entry<Integer, Integer> def : sortedVolunteers.entrySet()) {
                if (def.getValue() <= dif) {
                    count++;
                    sortedVolunteers.remove(def.getKey());
                    defPrev = entry.getKey();
                    break;
                }
            }
        }
        System.out.println(count);
    }

    /**
     * Сортировка Map
     *
     * @param map
     * @param <K>
     * @param <V>
     * @return
     */
    public static <K, V extends Comparable<? super V>> Map<K, V> sortByValue(Map<K, V> map) {
        Map<K, V> result = new LinkedHashMap<>();
        Stream<Map.Entry<K, V>> st = map.entrySet().stream();

        st.sorted(Comparator.comparing(e -> e.getValue()))
                .forEach(e -> result.put(e.getKey(), e.getValue()));

        return result;
    }

    /**
     * Сортировка map в обратном порядке
     *
     * @param map
     * @param <K>
     * @param <V>
     * @return
     */
    private static <K, V extends Comparable<? super V>> Map<K, V> sortByValueReverse(Map<K, V> map) {
        return map.entrySet()
                .stream()
                .sorted(Map.Entry.comparingByValue())
                .collect(Collectors.toMap(
                        Map.Entry::getKey,
                        Map.Entry::getValue,
                        (e1, e2) -> e1,
                        LinkedHashMap::new
                ));
    }
}
/*
Яндекс
Контест
Русский
egor140512@gmai…

Intern Backend Meetup
31 мар 2023, 16:35:01
старт:
31 мар 2023, 15:18:45
финиш:
31 мар 2023, 18:18:45
до финиша:
00:23:20
...
B. Защитники башни
Ограничение времени 	1 секунда
Ограничение памяти 	512Mb
Ввод 	стандартный ввод или input.txt
Вывод 	стандартный вывод или output.txt

На первой в нашей солнечной системе космической станции решили провести чемпионат системы по футболу. Из-за технических особенностей станции лучи света падают всегда строго вертикально вниз.

Для обеспечения безопасности станции была возвдена сторожевая башня. На башне друг под другом расположено n платформ одинаковой ширины. Длина i-й платформы равна ai.

Для повышения уровня безопасности был объявлен набор добровольцев-охранников. Всего заявки подали m человек. j-й доброволец имеет ширину плеч bj.

С башни открывается отличный вид на стадион, поэтому очень много добровольцев хотят на неё попасть. Но техника безопасности накладывает следущие условия:

    Охранник должен стоять на плите боком
    Ширина плеч охнанника не должна превышать длины патформы (чтобы сложнее было упасть).
    Охранник должен полностью находиться под освещением (чтобы было видно, что он не покинул пост).
    На одной платформе может быть не более одного охранника (два добровольца будут отвлекаться).

Изучите графическое представление первого теста ниже в примечании для лучшего понимания задачи.

Определите, какое максимальное число заявок можно принять.

Формат ввода
Первая строка входных данных содержит два числа n и m (1≤n,m≤2×105) — количество платформ, находящееся в башне, и количество добровольцев соответвенно.

Вторая строка входных данных содержит n натуральных чисел ai (1≤ai≤1018) — длина i-й платформы в порядке снизу вверх.

Третья строка входных данных содержит m натуральных чисел bj (1≤bj≤1018) — ширина плеч j-го добровольца.

Формат вывода
В единственной строке выведите максимальное число добровольцев-охранников, которых можно расположить на платформах, с учетом описанных условий.
Пример 1
Ввод
Вывод

5 3
7 3 4 2 2
3 2 1



3

Пример 2
Ввод
Вывод

2 1
2 10
11



0

Пример 3
Ввод
Вывод

5 4
100 98 96 40 30
2 4 60 3



3

Примечания
В первом тесте из условия есть 3 светлых участка:

1. 5-ю (самую верхнюю) платформу солнце освещает полностью, поэтому на ней находится солнечный участок размера 2;

2. 4-я платформа - так же размера 2, поэтому она полностью закрыта 5-й.

3. 3-я платформа имеет общий размер 4, поэтому солнечный участок на ней имеет размер 2 (над остальной частью платформы нависают платформы 5 и 4);

4. 2-я платформа имеет размер 3 и полностью закрыта от солнца платформой 3.

5. 1-я платформа имеет общий размер 7, поэтому солнечный участок на ней имеет размер 3 (остальную часть закрывает 3-я платформа).

Соответственно, доброволец с шириной плеч 3 займет место на солнечном участке 1-й платформы, а добровольцы с шириной плеч 1 и 2 могут встать на платформы 3 и 5 в любом порядке.

PIC

Язык
1

​

осталось 100 попыток
Посылок нет
СправкаОбратная связьПользовательское соглашение
© 2013–2023  ООО «Яндекс»

 */


/*
Яндекс
Контест
Русский
egor140512@gmai…

Intern Backend Meetup
31 мар 2023, 17:55:42
старт:
31 мар 2023, 15:18:45
финиш:
31 мар 2023, 18:18:45
до финиша:
00:22:49
...
C. Медиана нулей и единиц
Ограничение времени 	2 секунды
Ограничение памяти 	512Mb
Ввод 	стандартный ввод или input.txt
Вывод 	стандартный вывод или output.txt
В Yandex Research создали модель машинного обучения, которая генерирует алгоритмические задачки. Вам предстоит решить задачу, которую модель сгенерировала по запросу медиана нулей и единиц.

Дана строка S длины N, состоящая только из 0 и 1. Для каждого R от 1 до N необходимо найти любой индекс 1≤L<R такой, что SR является медианой подстроки S[L…R].

Определение: медиана строки S, состоящей только из 0 и 1, определяется следущим образом:

    обозначим за C0 количество 0 в строке S; аналогично C1  — количество 1.
    пусть C0>C1  — в таком случае медианой является 0; аналогично при C0<C1 медианой является 1.
    в случае C0=C1 медианой считается значение 0.5 (в рамках данной задачи достаточно знать, что данная медиана не равна ни 0, ни 1).

Пожалуйста, ознакомьтесь с примерами тестов и пояснениями к ним для лучшего понимания условия.

Формат ввода
В первой строке вводится целое число N (2≤N≤106)  — количество символов в строке S.

Во второй строке вводится строка S длины N, состоящая только из символов 0 и 1.
Формат вывода
Выведите N индексов LR, где 1≤LR<R и SR равно медиане отрезка S[LR…R].

Если для R не существует подобного индекса LR, то необходимо вывести −1.

Заметьте, что для R=1 ответа не существует по определению.

Пример 1
Ввод
Вывод

5
01001



-1 -1 1 1 -1

Пример 2
Ввод
Вывод

5
01011



-1 -1 1 2 2

Пример 3
Ввод
Вывод

4
0010



-1 1 -1 1

Примечания
Рассмотрим ответы на первый тестовый пример S=01001:

    L1=−1 по определению;
    L2 может быть равно только 1 или −1.

    Медиана подстроки S[1…2]=01 равна 12 по определению, что не равно S2=1. Поэтому L2=−1.
    L3=1, так как S3=0 и медиана подстроки S[1…3]=010 равна 0 (C0=2, C1=1).
    L4=1, так как S4=0 и медиана подстроки S[1…4]=0100 равна 0.

    Обратите внимание, что L4=2 и L4=3 также являются верными ответам, так как медианы подстрок S[2…4]=100 и S[3…4]=00 также равны 0.
    L5=−1, так как S5=1 и:
        медианы подстрок S[1…5]=01001 и S[3…5]=001 равны 0;
        медианы S[2…5]=1001 и S[4…5]=01 равны 12.

Рассмотрим ответы на второй тестовый пример S=01011:

    L1=−1 по определению;
    L2=−1, так как S2=1, а медиана единственной возможной подстроки S[1…2]=01 равна 12.
    L3=1, так как S3=0 и медиана подстроки S[1…3]=010 равна 0.
    L4=2, так как S4=1 и медиана подстроки S[2…4]=101 равна 1.
    L5=2, так как S5=1 и медиана подстроки S[2…5]=1011 равна 1.

    Обратите внимание, что L5=1, L5=3 и L5=4 также являются верными ответами, так как медианы подстрок S[1…5]=01011, S[3…5]=011 и S[4…5]=11 аналогично равны 1.

Рассмотрим ответы на третий тестовый пример S=0010:

    L1=−1 по определению;
    L2=1, так как S2=0 и медиана подстроки S[1…2]=00 равна 0.
    L3=−1, так как S3=1, а медианы всех возможных подстрок S[1…3]=001 и S[2…3]=01 равны 0 и 12 соответственно.
    L4=1, так как S4=0 и медиана подстроки S[1…4]=0010 равна 0.

    Обратите внимание, что L4=2 тоже является верным ответом, так как медиана подстроки S[2…4]=010 равна 0.

Язык
1

​

осталось 100 попыток

Посылок нет
СправкаОбратная связьПользовательское соглашение
© 2013–2023  ООО «Яндекс»

 */