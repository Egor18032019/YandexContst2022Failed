import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.List;

public class HHCookies {
    private static BufferedReader reader = null;
    public static int N; //количество мест
    public static int M; //количество выделенных часов
//    минимальное количество печенек K

    public static void main(String[] args) throws Exception {
        init();
        run();
    }

    private static void init() {
        reader = new BufferedReader(new InputStreamReader(System.in));
    }

    private static void run() throws IOException {
        String[] firstLine = reader.readLine().split(" ");
        N = Integer.parseInt(firstLine[0]); // места
        M = Integer.parseInt(firstLine[1]); // время
        if (N > M) {
            System.out.println(0);
            return;
        }
        int max = 0;
        int min = Integer.MAX_VALUE;
        int withCookies = 0;
        int sum = 0;
        List<Integer> allCookies = new ArrayList<>();
        for (int i = 0; i < N; i++) {
            String line = reader.readLine();
            int number = Integer.parseInt(line);
            if (number > max) max = number;
            if (number < min) min = number;

            if (number != 0) {
                sum = sum + number;
                withCookies++;
                allCookies.add(number);
            }
        }
//         int dif = M - N + 1;
        if (withCookies == M) {
            System.out.println(max);
            return;
        }
        if (withCookies == 0) {
            System.out.println(0);
            return;
        }
        int average = canEatAllCookies((sum / M), allCookies); //21
        System.out.println(average);
    }

    //. Последний статус: превышение лимита времени выполнения
    private static int canEatAllCookies(int average, List<Integer> allCookies) {
        int score = M;
// 2.6
        for (int point : allCookies) {
            double x = point;
            double y = average;
            int foo = (int) Math.ceil(x / y);
            score = score - foo;
        }

        if (score >= 0) {
            return average;
        } else {
            return canEatAllCookies(average + 1, allCookies);
        }
    }
}
/*
4 6
1
20
80
100
-50 : 33

5 6
1
20
80
90
100
-90

3 6
1
25
100
-25 : 21
 **/


/**
 * Задача 1. Офисные печеньки
 * Условие задачи
 * Ограничение времени, с	1
 * Ограничение памяти, МБ	64
 * Общее число попыток отправки	15
 * <p>
 * Разработчик Фёдор очень любит печеньки в офисе, и он точно знает все N мест, где их можно найти, а также точное количество печенек Сn в каждом месте. Сегодня Фёдор особенно голоден, он закончил большую задачу, и решает выделить себе M часов на то, чтобы съесть все печеньки в офисе.
 * <p>
 * Фёдор рассчитал минимальное количество печенек K, которое ему нужно съедать в течение часа так, чтобы в итоге успеть съесть все печеньки в офисе за выделенное время.
 * <p>
 * В каждый час, он может посетить одно любое место с печеньками и съесть K печенек в этом месте, он потратит на это целый час, даже если в этом месте осталось меньше, чем K печенек, потому что будет обсуждать с коллегами задачи и планы. Места без печенек Фёдор может не посещать.
 * <p>
 * Коллеги, из уважения к Фёдору, никогда не трогают его любимые печеньки
 * <p>
 * Входные данные (поступают в стандартный поток ввода)
 * <p>
 * Первая строка - целые числа N и M через пробел (1≤N≤100 000, 1≤M≤200 000)
 * <p>
 * Далее N строк, на каждой из которых одно целое число Cn (0≤Cn≤10 000)
 * <p>
 * Все входные данные наших тестов всегда соблюдают указанные параметры, дополнительные проверки не требуются
 * <p>
 * Выходные данные (ожидаются в стандартном потоке вывода)
 * <p>
 * Одно целое число, минимально возможное K. Либо 0, если в офисе нет печенек, или если Фёдор не успеет съесть все печеньки за выделенное время.
 * <p>
 * Пример 1
 * <p>
 * Ввод:
 * <p>
 * 3 6
 * 4
 * 4
 * 4
 * <p>
 * Вывод:
 * <p>
 * 2
 * <p>
 * Простой пример для ознакомления с входными и выходными данными
 * <p>
 * Пример 2
 * <p>
 * Ввод:
 * <p>
 * 3 6
 * 4
 * 4
 * 5
 * <p>
 * Вывод:
 * <p>
 * 3
 * <p>
 * Здесь похожая ситуация, но съедая по 2 печеньки, Фёдор не успеет съесть последнюю
 * <p>
 * Пример 3
 * <p>
 * Ввод:
 * <p>
 * 3 3
 * 6
 * 6
 * 8
 * <p>
 * Вывод:
 * <p>
 * 8
 * <p>
 * Граничная ситуация при N = M
 * <p>
 * <p>
 * Примечания по оформлению решения
 * <p>
 * Возможно использование только стандартных библиотек языков, установки и использование дополнительных библиотек невозможны.
 * <p>
 * При отправке решений на Java необходимо назвать исполняемый класс Main. В решении не нужно указывать пакет.
 * <p>
 * Примеры работы со стандартными потоками ввода и вывода
 * <p>
 * Для JS можно использовать readline и console.log:
 * <p>
 * const readline = require('readline').createInterface(process.stdin, process.stdout);
 * readline.on('line', (line) => {
 * // Введенная строка в переменной line, тут можно написать решение и вывести его с помощью console.log
 * ...
 * console.log(String(result));
 * readline.close();
 * }).on('close', () => process.exit(0));
 * <p>
 * <p>
 * в Python можно использовать встроенные функции input() и print():
 * <p>
 * line = input()
 * ...
 * print(result)
 * <p>
 * <p>
 * в Java можно использовать java.util.Scanner и System.out.println:
 * <p>
 * Scanner in = new Scanner(System.in);
 * String line = in.nextLine();
 * ...
 * System.out.println(result);
 * <p>
 * <p>
 * Перед отправкой решения рекомендуем запустить тесты из раздела Тестирование, они помогут поймать
 * синтаксические ошибки и ошибки выполнения.
 * <p>
 * Задача 1. Офисные печеньки
 * Условие задачи
 * Ограничение времени, с	1
 * Ограничение памяти, МБ	64
 * Общее число попыток отправки	15
 * <p>
 * Разработчик Фёдор очень любит печеньки в офисе, и он точно знает все N мест, где их можно найти, а также точное количество печенек Сn в каждом месте. Сегодня Фёдор особенно голоден, он закончил большую задачу, и решает выделить себе M часов на то, чтобы съесть все печеньки в офисе.
 * <p>
 * Фёдор рассчитал минимальное количество печенек K, которое ему нужно съедать в течение часа так, чтобы в итоге успеть съесть все печеньки в офисе за выделенное время.
 * <p>
 * В каждый час, он может посетить одно любое место с печеньками и съесть K печенек в этом месте, он потратит на это целый час, даже если в этом месте осталось меньше, чем K печенек, потому что будет обсуждать с коллегами задачи и планы. Места без печенек Фёдор может не посещать.
 * <p>
 * Коллеги, из уважения к Фёдору, никогда не трогают его любимые печеньки
 * <p>
 * Входные данные (поступают в стандартный поток ввода)
 * <p>
 * Первая строка - целые числа N и M через пробел (1≤N≤100 000, 1≤M≤200 000)
 * <p>
 * Далее N строк, на каждой из которых одно целое число Cn (0≤Cn≤10 000)
 * <p>
 * Все входные данные наших тестов всегда соблюдают указанные параметры, дополнительные проверки не требуются
 * <p>
 * Выходные данные (ожидаются в стандартном потоке вывода)
 * <p>
 * Одно целое число, минимально возможное K. Либо 0, если в офисе нет печенек, или если Фёдор не успеет съесть все печеньки за выделенное время.
 * <p>
 * Пример 1
 * <p>
 * Ввод:
 * <p>
 * 3 6
 * 4
 * 4
 * 4
 * <p>
 * Вывод:
 * <p>
 * 2
 * <p>
 * Простой пример для ознакомления с входными и выходными данными
 * <p>
 * Пример 2
 * <p>
 * Ввод:
 * <p>
 * 3 6
 * 4
 * 4
 * 5
 * <p>
 * Вывод:
 * <p>
 * 3
 * <p>
 * Здесь похожая ситуация, но съедая по 2 печеньки, Фёдор не успеет съесть последнюю
 * <p>
 * Пример 3
 * <p>
 * Ввод:
 * <p>
 * 3 3
 * 6
 * 6
 * 8
 * <p>
 * Вывод:
 * <p>
 * 8
 * <p>
 * Граничная ситуация при N = M
 * <p>
 * <p>
 * Примечания по оформлению решения
 * <p>
 * Возможно использование только стандартных библиотек языков, установки и использование дополнительных библиотек невозможны.
 * <p>
 * При отправке решений на Java необходимо назвать исполняемый класс Main. В решении не нужно указывать пакет.
 * <p>
 * Примеры работы со стандартными потоками ввода и вывода
 * <p>
 * Для JS можно использовать readline и console.log:
 * <p>
 * const readline = require('readline').createInterface(process.stdin, process.stdout);
 * readline.on('line', (line) => {
 * // Введенная строка в переменной line, тут можно написать решение и вывести его с помощью console.log
 * ...
 * console.log(String(result));
 * readline.close();
 * }).on('close', () => process.exit(0));
 * <p>
 * <p>
 * в Python можно использовать встроенные функции input() и print():
 * <p>
 * line = input()
 * ...
 * print(result)
 * <p>
 * <p>
 * в Java можно использовать java.util.Scanner и System.out.println:
 * <p>
 * Scanner in = new Scanner(System.in);
 * String line = in.nextLine();
 * ...
 * System.out.println(result);
 * <p>
 * <p>
 * Перед отправкой решения рекомендуем запустить тесты из раздела Тестирование, они помогут поймать
 * синтаксические ошибки и ошибки выполнения.
 * <p>
 * Задача 1. Офисные печеньки
 * Условие задачи
 * Ограничение времени, с	1
 * Ограничение памяти, МБ	64
 * Общее число попыток отправки	15
 * <p>
 * Разработчик Фёдор очень любит печеньки в офисе, и он точно знает все N мест, где их можно найти, а также точное количество печенек Сn в каждом месте. Сегодня Фёдор особенно голоден, он закончил большую задачу, и решает выделить себе M часов на то, чтобы съесть все печеньки в офисе.
 * <p>
 * Фёдор рассчитал минимальное количество печенек K, которое ему нужно съедать в течение часа так, чтобы в итоге успеть съесть все печеньки в офисе за выделенное время.
 * <p>
 * В каждый час, он может посетить одно любое место с печеньками и съесть K печенек в этом месте, он потратит на это целый час, даже если в этом месте осталось меньше, чем K печенек, потому что будет обсуждать с коллегами задачи и планы. Места без печенек Фёдор может не посещать.
 * <p>
 * Коллеги, из уважения к Фёдору, никогда не трогают его любимые печеньки
 * <p>
 * Входные данные (поступают в стандартный поток ввода)
 * <p>
 * Первая строка - целые числа N и M через пробел (1≤N≤100 000, 1≤M≤200 000)
 * <p>
 * Далее N строк, на каждой из которых одно целое число Cn (0≤Cn≤10 000)
 * <p>
 * Все входные данные наших тестов всегда соблюдают указанные параметры, дополнительные проверки не требуются
 * <p>
 * Выходные данные (ожидаются в стандартном потоке вывода)
 * <p>
 * Одно целое число, минимально возможное K. Либо 0, если в офисе нет печенек, или если Фёдор не успеет съесть все печеньки за выделенное время.
 * <p>
 * Пример 1
 * <p>
 * Ввод:
 * <p>
 * 3 6
 * 4
 * 4
 * 4
 * <p>
 * Вывод:
 * <p>
 * 2
 * <p>
 * Простой пример для ознакомления с входными и выходными данными
 * <p>
 * Пример 2
 * <p>
 * Ввод:
 * <p>
 * 3 6
 * 4
 * 4
 * 5
 * <p>
 * Вывод:
 * <p>
 * 3
 * <p>
 * Здесь похожая ситуация, но съедая по 2 печеньки, Фёдор не успеет съесть последнюю
 * <p>
 * Пример 3
 * <p>
 * Ввод:
 * <p>
 * 3 3
 * 6
 * 6
 * 8
 * <p>
 * Вывод:
 * <p>
 * 8
 * <p>
 * Граничная ситуация при N = M
 * <p>
 * <p>
 * Примечания по оформлению решения
 * <p>
 * Возможно использование только стандартных библиотек языков, установки и использование дополнительных библиотек невозможны.
 * <p>
 * При отправке решений на Java необходимо назвать исполняемый класс Main. В решении не нужно указывать пакет.
 * <p>
 * Примеры работы со стандартными потоками ввода и вывода
 * <p>
 * Для JS можно использовать readline и console.log:
 * <p>
 * const readline = require('readline').createInterface(process.stdin, process.stdout);
 * readline.on('line', (line) => {
 * // Введенная строка в переменной line, тут можно написать решение и вывести его с помощью console.log
 * ...
 * console.log(String(result));
 * readline.close();
 * }).on('close', () => process.exit(0));
 * <p>
 * <p>
 * в Python можно использовать встроенные функции input() и print():
 * <p>
 * line = input()
 * ...
 * print(result)
 * <p>
 * <p>
 * в Java можно использовать java.util.Scanner и System.out.println:
 * <p>
 * Scanner in = new Scanner(System.in);
 * String line = in.nextLine();
 * ...
 * System.out.println(result);
 * <p>
 * <p>
 * Перед отправкой решения рекомендуем запустить тесты из раздела Тестирование, они помогут поймать
 * синтаксические ошибки и ошибки выполнения.
 * <p>
 * Задача 1. Офисные печеньки
 * Условие задачи
 * Ограничение времени, с	1
 * Ограничение памяти, МБ	64
 * Общее число попыток отправки	15
 * <p>
 * Разработчик Фёдор очень любит печеньки в офисе, и он точно знает все N мест, где их можно найти, а также точное количество печенек Сn в каждом месте. Сегодня Фёдор особенно голоден, он закончил большую задачу, и решает выделить себе M часов на то, чтобы съесть все печеньки в офисе.
 * <p>
 * Фёдор рассчитал минимальное количество печенек K, которое ему нужно съедать в течение часа так, чтобы в итоге успеть съесть все печеньки в офисе за выделенное время.
 * <p>
 * В каждый час, он может посетить одно любое место с печеньками и съесть K печенек в этом месте, он потратит на это целый час, даже если в этом месте осталось меньше, чем K печенек, потому что будет обсуждать с коллегами задачи и планы. Места без печенек Фёдор может не посещать.
 * <p>
 * Коллеги, из уважения к Фёдору, никогда не трогают его любимые печеньки
 * <p>
 * Входные данные (поступают в стандартный поток ввода)
 * <p>
 * Первая строка - целые числа N и M через пробел (1≤N≤100 000, 1≤M≤200 000)
 * <p>
 * Далее N строк, на каждой из которых одно целое число Cn (0≤Cn≤10 000)
 * <p>
 * Все входные данные наших тестов всегда соблюдают указанные параметры, дополнительные проверки не требуются
 * <p>
 * Выходные данные (ожидаются в стандартном потоке вывода)
 * <p>
 * Одно целое число, минимально возможное K. Либо 0, если в офисе нет печенек, или если Фёдор не успеет съесть все печеньки за выделенное время.
 * <p>
 * Пример 1
 * <p>
 * Ввод:
 * <p>
 * 3 6
 * 4
 * 4
 * 4
 * <p>
 * Вывод:
 * <p>
 * 2
 * <p>
 * Простой пример для ознакомления с входными и выходными данными
 * <p>
 * Пример 2
 * <p>
 * Ввод:
 * <p>
 * 3 6
 * 4
 * 4
 * 5
 * <p>
 * Вывод:
 * <p>
 * 3
 * <p>
 * Здесь похожая ситуация, но съедая по 2 печеньки, Фёдор не успеет съесть последнюю
 * <p>
 * Пример 3
 * <p>
 * Ввод:
 * <p>
 * 3 3
 * 6
 * 6
 * 8
 * <p>
 * Вывод:
 * <p>
 * 8
 * <p>
 * Граничная ситуация при N = M
 * <p>
 * <p>
 * Примечания по оформлению решения
 * <p>
 * Возможно использование только стандартных библиотек языков, установки и использование дополнительных библиотек невозможны.
 * <p>
 * При отправке решений на Java необходимо назвать исполняемый класс Main. В решении не нужно указывать пакет.
 * <p>
 * Примеры работы со стандартными потоками ввода и вывода
 * <p>
 * Для JS можно использовать readline и console.log:
 * <p>
 * const readline = require('readline').createInterface(process.stdin, process.stdout);
 * readline.on('line', (line) => {
 * // Введенная строка в переменной line, тут можно написать решение и вывести его с помощью console.log
 * ...
 * console.log(String(result));
 * readline.close();
 * }).on('close', () => process.exit(0));
 * <p>
 * <p>
 * в Python можно использовать встроенные функции input() и print():
 * <p>
 * line = input()
 * ...
 * print(result)
 * <p>
 * <p>
 * в Java можно использовать java.util.Scanner и System.out.println:
 * <p>
 * Scanner in = new Scanner(System.in);
 * String line = in.nextLine();
 * ...
 * System.out.println(result);
 * <p>
 * <p>
 * Перед отправкой решения рекомендуем запустить тесты из раздела Тестирование, они помогут поймать
 * синтаксические ошибки и ошибки выполнения.
 * <p>
 * Задача 1. Офисные печеньки
 * Условие задачи
 * Ограничение времени, с	1
 * Ограничение памяти, МБ	64
 * Общее число попыток отправки	15
 * <p>
 * Разработчик Фёдор очень любит печеньки в офисе, и он точно знает все N мест, где их можно найти, а также точное количество печенек Сn в каждом месте. Сегодня Фёдор особенно голоден, он закончил большую задачу, и решает выделить себе M часов на то, чтобы съесть все печеньки в офисе.
 * <p>
 * Фёдор рассчитал минимальное количество печенек K, которое ему нужно съедать в течение часа так, чтобы в итоге успеть съесть все печеньки в офисе за выделенное время.
 * <p>
 * В каждый час, он может посетить одно любое место с печеньками и съесть K печенек в этом месте, он потратит на это целый час, даже если в этом месте осталось меньше, чем K печенек, потому что будет обсуждать с коллегами задачи и планы. Места без печенек Фёдор может не посещать.
 * <p>
 * Коллеги, из уважения к Фёдору, никогда не трогают его любимые печеньки
 * <p>
 * Входные данные (поступают в стандартный поток ввода)
 * <p>
 * Первая строка - целые числа N и M через пробел (1≤N≤100 000, 1≤M≤200 000)
 * <p>
 * Далее N строк, на каждой из которых одно целое число Cn (0≤Cn≤10 000)
 * <p>
 * Все входные данные наших тестов всегда соблюдают указанные параметры, дополнительные проверки не требуются
 * <p>
 * Выходные данные (ожидаются в стандартном потоке вывода)
 * <p>
 * Одно целое число, минимально возможное K. Либо 0, если в офисе нет печенек, или если Фёдор не успеет съесть все печеньки за выделенное время.
 * <p>
 * Пример 1
 * <p>
 * Ввод:
 * <p>
 * 3 6
 * 4
 * 4
 * 4
 * <p>
 * Вывод:
 * <p>
 * 2
 * <p>
 * Простой пример для ознакомления с входными и выходными данными
 * <p>
 * Пример 2
 * <p>
 * Ввод:
 * <p>
 * 3 6
 * 4
 * 4
 * 5
 * <p>
 * Вывод:
 * <p>
 * 3
 * <p>
 * Здесь похожая ситуация, но съедая по 2 печеньки, Фёдор не успеет съесть последнюю
 * <p>
 * Пример 3
 * <p>
 * Ввод:
 * <p>
 * 3 3
 * 6
 * 6
 * 8
 * <p>
 * Вывод:
 * <p>
 * 8
 * <p>
 * Граничная ситуация при N = M
 * <p>
 * <p>
 * Примечания по оформлению решения
 * <p>
 * Возможно использование только стандартных библиотек языков, установки и использование дополнительных библиотек невозможны.
 * <p>
 * При отправке решений на Java необходимо назвать исполняемый класс Main. В решении не нужно указывать пакет.
 * <p>
 * Примеры работы со стандартными потоками ввода и вывода
 * <p>
 * Для JS можно использовать readline и console.log:
 * <p>
 * const readline = require('readline').createInterface(process.stdin, process.stdout);
 * readline.on('line', (line) => {
 * // Введенная строка в переменной line, тут можно написать решение и вывести его с помощью console.log
 * ...
 * console.log(String(result));
 * readline.close();
 * }).on('close', () => process.exit(0));
 * <p>
 * <p>
 * в Python можно использовать встроенные функции input() и print():
 * <p>
 * line = input()
 * ...
 * print(result)
 * <p>
 * <p>
 * в Java можно использовать java.util.Scanner и System.out.println:
 * <p>
 * Scanner in = new Scanner(System.in);
 * String line = in.nextLine();
 * ...
 * System.out.println(result);
 * <p>
 * <p>
 * Перед отправкой решения рекомендуем запустить тесты из раздела Тестирование, они помогут поймать
 * синтаксические ошибки и ошибки выполнения.
 * <p>
 * Задача 1. Офисные печеньки
 * Условие задачи
 * Ограничение времени, с	1
 * Ограничение памяти, МБ	64
 * Общее число попыток отправки	15
 * <p>
 * Разработчик Фёдор очень любит печеньки в офисе, и он точно знает все N мест, где их можно найти, а также точное количество печенек Сn в каждом месте. Сегодня Фёдор особенно голоден, он закончил большую задачу, и решает выделить себе M часов на то, чтобы съесть все печеньки в офисе.
 * <p>
 * Фёдор рассчитал минимальное количество печенек K, которое ему нужно съедать в течение часа так, чтобы в итоге успеть съесть все печеньки в офисе за выделенное время.
 * <p>
 * В каждый час, он может посетить одно любое место с печеньками и съесть K печенек в этом месте, он потратит на это целый час, даже если в этом месте осталось меньше, чем K печенек, потому что будет обсуждать с коллегами задачи и планы. Места без печенек Фёдор может не посещать.
 * <p>
 * Коллеги, из уважения к Фёдору, никогда не трогают его любимые печеньки
 * <p>
 * Входные данные (поступают в стандартный поток ввода)
 * <p>
 * Первая строка - целые числа N и M через пробел (1≤N≤100 000, 1≤M≤200 000)
 * <p>
 * Далее N строк, на каждой из которых одно целое число Cn (0≤Cn≤10 000)
 * <p>
 * Все входные данные наших тестов всегда соблюдают указанные параметры, дополнительные проверки не требуются
 * <p>
 * Выходные данные (ожидаются в стандартном потоке вывода)
 * <p>
 * Одно целое число, минимально возможное K. Либо 0, если в офисе нет печенек, или если Фёдор не успеет съесть все печеньки за выделенное время.
 * <p>
 * Пример 1
 * <p>
 * Ввод:
 * <p>
 * 3 6
 * 4
 * 4
 * 4
 * <p>
 * Вывод:
 * <p>
 * 2
 * <p>
 * Простой пример для ознакомления с входными и выходными данными
 * <p>
 * Пример 2
 * <p>
 * Ввод:
 * <p>
 * 3 6
 * 4
 * 4
 * 5
 * <p>
 * Вывод:
 * <p>
 * 3
 * <p>
 * Здесь похожая ситуация, но съедая по 2 печеньки, Фёдор не успеет съесть последнюю
 * <p>
 * Пример 3
 * <p>
 * Ввод:
 * <p>
 * 3 3
 * 6
 * 6
 * 8
 * <p>
 * Вывод:
 * <p>
 * 8
 * <p>
 * Граничная ситуация при N = M
 * <p>
 * <p>
 * Примечания по оформлению решения
 * <p>
 * Возможно использование только стандартных библиотек языков, установки и использование дополнительных библиотек невозможны.
 * <p>
 * При отправке решений на Java необходимо назвать исполняемый класс Main. В решении не нужно указывать пакет.
 * <p>
 * Примеры работы со стандартными потоками ввода и вывода
 * <p>
 * Для JS можно использовать readline и console.log:
 * <p>
 * const readline = require('readline').createInterface(process.stdin, process.stdout);
 * readline.on('line', (line) => {
 * // Введенная строка в переменной line, тут можно написать решение и вывести его с помощью console.log
 * ...
 * console.log(String(result));
 * readline.close();
 * }).on('close', () => process.exit(0));
 * <p>
 * <p>
 * в Python можно использовать встроенные функции input() и print():
 * <p>
 * line = input()
 * ...
 * print(result)
 * <p>
 * <p>
 * в Java можно использовать java.util.Scanner и System.out.println:
 * <p>
 * Scanner in = new Scanner(System.in);
 * String line = in.nextLine();
 * ...
 * System.out.println(result);
 * <p>
 * <p>
 * Перед отправкой решения рекомендуем запустить тесты из раздела Тестирование, они помогут поймать
 * синтаксические ошибки и ошибки выполнения.
 * <p>
 * Задача 1. Офисные печеньки
 * Условие задачи
 * Ограничение времени, с	1
 * Ограничение памяти, МБ	64
 * Общее число попыток отправки	15
 * <p>
 * Разработчик Фёдор очень любит печеньки в офисе, и он точно знает все N мест, где их можно найти, а также точное количество печенек Сn в каждом месте. Сегодня Фёдор особенно голоден, он закончил большую задачу, и решает выделить себе M часов на то, чтобы съесть все печеньки в офисе.
 * <p>
 * Фёдор рассчитал минимальное количество печенек K, которое ему нужно съедать в течение часа так, чтобы в итоге успеть съесть все печеньки в офисе за выделенное время.
 * <p>
 * В каждый час, он может посетить одно любое место с печеньками и съесть K печенек в этом месте, он потратит на это целый час, даже если в этом месте осталось меньше, чем K печенек, потому что будет обсуждать с коллегами задачи и планы. Места без печенек Фёдор может не посещать.
 * <p>
 * Коллеги, из уважения к Фёдору, никогда не трогают его любимые печеньки
 * <p>
 * Входные данные (поступают в стандартный поток ввода)
 * <p>
 * Первая строка - целые числа N и M через пробел (1≤N≤100 000, 1≤M≤200 000)
 * <p>
 * Далее N строк, на каждой из которых одно целое число Cn (0≤Cn≤10 000)
 * <p>
 * Все входные данные наших тестов всегда соблюдают указанные параметры, дополнительные проверки не требуются
 * <p>
 * Выходные данные (ожидаются в стандартном потоке вывода)
 * <p>
 * Одно целое число, минимально возможное K. Либо 0, если в офисе нет печенек, или если Фёдор не успеет съесть все печеньки за выделенное время.
 * <p>
 * Пример 1
 * <p>
 * Ввод:
 * <p>
 * 3 6
 * 4
 * 4
 * 4
 * <p>
 * Вывод:
 * <p>
 * 2
 * <p>
 * Простой пример для ознакомления с входными и выходными данными
 * <p>
 * Пример 2
 * <p>
 * Ввод:
 * <p>
 * 3 6
 * 4
 * 4
 * 5
 * <p>
 * Вывод:
 * <p>
 * 3
 * <p>
 * Здесь похожая ситуация, но съедая по 2 печеньки, Фёдор не успеет съесть последнюю
 * <p>
 * Пример 3
 * <p>
 * Ввод:
 * <p>
 * 3 3
 * 6
 * 6
 * 8
 * <p>
 * Вывод:
 * <p>
 * 8
 * <p>
 * Граничная ситуация при N = M
 * <p>
 * <p>
 * Примечания по оформлению решения
 * <p>
 * Возможно использование только стандартных библиотек языков, установки и использование дополнительных библиотек невозможны.
 * <p>
 * При отправке решений на Java необходимо назвать исполняемый класс Main. В решении не нужно указывать пакет.
 * <p>
 * Примеры работы со стандартными потоками ввода и вывода
 * <p>
 * Для JS можно использовать readline и console.log:
 * <p>
 * const readline = require('readline').createInterface(process.stdin, process.stdout);
 * readline.on('line', (line) => {
 * // Введенная строка в переменной line, тут можно написать решение и вывести его с помощью console.log
 * ...
 * console.log(String(result));
 * readline.close();
 * }).on('close', () => process.exit(0));
 * <p>
 * <p>
 * в Python можно использовать встроенные функции input() и print():
 * <p>
 * line = input()
 * ...
 * print(result)
 * <p>
 * <p>
 * в Java можно использовать java.util.Scanner и System.out.println:
 * <p>
 * Scanner in = new Scanner(System.in);
 * String line = in.nextLine();
 * ...
 * System.out.println(result);
 * <p>
 * <p>
 * Перед отправкой решения рекомендуем запустить тесты из раздела Тестирование, они помогут поймать
 * синтаксические ошибки и ошибки выполнения.
 * <p>
 * Задача 1. Офисные печеньки
 * Условие задачи
 * Ограничение времени, с	1
 * Ограничение памяти, МБ	64
 * Общее число попыток отправки	15
 * <p>
 * Разработчик Фёдор очень любит печеньки в офисе, и он точно знает все N мест, где их можно найти, а также точное количество печенек Сn в каждом месте. Сегодня Фёдор особенно голоден, он закончил большую задачу, и решает выделить себе M часов на то, чтобы съесть все печеньки в офисе.
 * <p>
 * Фёдор рассчитал минимальное количество печенек K, которое ему нужно съедать в течение часа так, чтобы в итоге успеть съесть все печеньки в офисе за выделенное время.
 * <p>
 * В каждый час, он может посетить одно любое место с печеньками и съесть K печенек в этом месте, он потратит на это целый час, даже если в этом месте осталось меньше, чем K печенек, потому что будет обсуждать с коллегами задачи и планы. Места без печенек Фёдор может не посещать.
 * <p>
 * Коллеги, из уважения к Фёдору, никогда не трогают его любимые печеньки
 * <p>
 * Входные данные (поступают в стандартный поток ввода)
 * <p>
 * Первая строка - целые числа N и M через пробел (1≤N≤100 000, 1≤M≤200 000)
 * <p>
 * Далее N строк, на каждой из которых одно целое число Cn (0≤Cn≤10 000)
 * <p>
 * Все входные данные наших тестов всегда соблюдают указанные параметры, дополнительные проверки не требуются
 * <p>
 * Выходные данные (ожидаются в стандартном потоке вывода)
 * <p>
 * Одно целое число, минимально возможное K. Либо 0, если в офисе нет печенек, или если Фёдор не успеет съесть все печеньки за выделенное время.
 * <p>
 * Пример 1
 * <p>
 * Ввод:
 * <p>
 * 3 6
 * 4
 * 4
 * 4
 * <p>
 * Вывод:
 * <p>
 * 2
 * <p>
 * Простой пример для ознакомления с входными и выходными данными
 * <p>
 * Пример 2
 * <p>
 * Ввод:
 * <p>
 * 3 6
 * 4
 * 4
 * 5
 * <p>
 * Вывод:
 * <p>
 * 3
 * <p>
 * Здесь похожая ситуация, но съедая по 2 печеньки, Фёдор не успеет съесть последнюю
 * <p>
 * Пример 3
 * <p>
 * Ввод:
 * <p>
 * 3 3
 * 6
 * 6
 * 8
 * <p>
 * Вывод:
 * <p>
 * 8
 * <p>
 * Граничная ситуация при N = M
 * <p>
 * <p>
 * Примечания по оформлению решения
 * <p>
 * Возможно использование только стандартных библиотек языков, установки и использование дополнительных библиотек невозможны.
 * <p>
 * При отправке решений на Java необходимо назвать исполняемый класс Main. В решении не нужно указывать пакет.
 * <p>
 * Примеры работы со стандартными потоками ввода и вывода
 * <p>
 * Для JS можно использовать readline и console.log:
 * <p>
 * const readline = require('readline').createInterface(process.stdin, process.stdout);
 * readline.on('line', (line) => {
 * // Введенная строка в переменной line, тут можно написать решение и вывести его с помощью console.log
 * ...
 * console.log(String(result));
 * readline.close();
 * }).on('close', () => process.exit(0));
 * <p>
 * <p>
 * в Python можно использовать встроенные функции input() и print():
 * <p>
 * line = input()
 * ...
 * print(result)
 * <p>
 * <p>
 * в Java можно использовать java.util.Scanner и System.out.println:
 * <p>
 * Scanner in = new Scanner(System.in);
 * String line = in.nextLine();
 * ...
 * System.out.println(result);
 * <p>
 * <p>
 * Перед отправкой решения рекомендуем запустить тесты из раздела Тестирование, они помогут поймать
 * синтаксические ошибки и ошибки выполнения.
 * <p>
 * Задача 1. Офисные печеньки
 * Условие задачи
 * Ограничение времени, с	1
 * Ограничение памяти, МБ	64
 * Общее число попыток отправки	15
 * <p>
 * Разработчик Фёдор очень любит печеньки в офисе, и он точно знает все N мест, где их можно найти, а также точное количество печенек Сn в каждом месте. Сегодня Фёдор особенно голоден, он закончил большую задачу, и решает выделить себе M часов на то, чтобы съесть все печеньки в офисе.
 * <p>
 * Фёдор рассчитал минимальное количество печенек K, которое ему нужно съедать в течение часа так, чтобы в итоге успеть съесть все печеньки в офисе за выделенное время.
 * <p>
 * В каждый час, он может посетить одно любое место с печеньками и съесть K печенек в этом месте, он потратит на это целый час, даже если в этом месте осталось меньше, чем K печенек, потому что будет обсуждать с коллегами задачи и планы. Места без печенек Фёдор может не посещать.
 * <p>
 * Коллеги, из уважения к Фёдору, никогда не трогают его любимые печеньки
 * <p>
 * Входные данные (поступают в стандартный поток ввода)
 * <p>
 * Первая строка - целые числа N и M через пробел (1≤N≤100 000, 1≤M≤200 000)
 * <p>
 * Далее N строк, на каждой из которых одно целое число Cn (0≤Cn≤10 000)
 * <p>
 * Все входные данные наших тестов всегда соблюдают указанные параметры, дополнительные проверки не требуются
 * <p>
 * Выходные данные (ожидаются в стандартном потоке вывода)
 * <p>
 * Одно целое число, минимально возможное K. Либо 0, если в офисе нет печенек, или если Фёдор не успеет съесть все печеньки за выделенное время.
 * <p>
 * Пример 1
 * <p>
 * Ввод:
 * <p>
 * 3 6
 * 4
 * 4
 * 4
 * <p>
 * Вывод:
 * <p>
 * 2
 * <p>
 * Простой пример для ознакомления с входными и выходными данными
 * <p>
 * Пример 2
 * <p>
 * Ввод:
 * <p>
 * 3 6
 * 4
 * 4
 * 5
 * <p>
 * Вывод:
 * <p>
 * 3
 * <p>
 * Здесь похожая ситуация, но съедая по 2 печеньки, Фёдор не успеет съесть последнюю
 * <p>
 * Пример 3
 * <p>
 * Ввод:
 * <p>
 * 3 3
 * 6
 * 6
 * 8
 * <p>
 * Вывод:
 * <p>
 * 8
 * <p>
 * Граничная ситуация при N = M
 * <p>
 * <p>
 * Примечания по оформлению решения
 * <p>
 * Возможно использование только стандартных библиотек языков, установки и использование дополнительных библиотек невозможны.
 * <p>
 * При отправке решений на Java необходимо назвать исполняемый класс Main. В решении не нужно указывать пакет.
 * <p>
 * Примеры работы со стандартными потоками ввода и вывода
 * <p>
 * Для JS можно использовать readline и console.log:
 * <p>
 * const readline = require('readline').createInterface(process.stdin, process.stdout);
 * readline.on('line', (line) => {
 * // Введенная строка в переменной line, тут можно написать решение и вывести его с помощью console.log
 * ...
 * console.log(String(result));
 * readline.close();
 * }).on('close', () => process.exit(0));
 * <p>
 * <p>
 * в Python можно использовать встроенные функции input() и print():
 * <p>
 * line = input()
 * ...
 * print(result)
 * <p>
 * <p>
 * в Java можно использовать java.util.Scanner и System.out.println:
 * <p>
 * Scanner in = new Scanner(System.in);
 * String line = in.nextLine();
 * ...
 * System.out.println(result);
 * <p>
 * <p>
 * Перед отправкой решения рекомендуем запустить тесты из раздела Тестирование, они помогут поймать
 * синтаксические ошибки и ошибки выполнения.
 * <p>
 * Задача 1. Офисные печеньки
 * Условие задачи
 * Ограничение времени, с	1
 * Ограничение памяти, МБ	64
 * Общее число попыток отправки	15
 * <p>
 * Разработчик Фёдор очень любит печеньки в офисе, и он точно знает все N мест, где их можно найти, а также точное количество печенек Сn в каждом месте. Сегодня Фёдор особенно голоден, он закончил большую задачу, и решает выделить себе M часов на то, чтобы съесть все печеньки в офисе.
 * <p>
 * Фёдор рассчитал минимальное количество печенек K, которое ему нужно съедать в течение часа так, чтобы в итоге успеть съесть все печеньки в офисе за выделенное время.
 * <p>
 * В каждый час, он может посетить одно любое место с печеньками и съесть K печенек в этом месте, он потратит на это целый час, даже если в этом месте осталось меньше, чем K печенек, потому что будет обсуждать с коллегами задачи и планы. Места без печенек Фёдор может не посещать.
 * <p>
 * Коллеги, из уважения к Фёдору, никогда не трогают его любимые печеньки
 * <p>
 * Входные данные (поступают в стандартный поток ввода)
 * <p>
 * Первая строка - целые числа N и M через пробел (1≤N≤100 000, 1≤M≤200 000)
 * <p>
 * Далее N строк, на каждой из которых одно целое число Cn (0≤Cn≤10 000)
 * <p>
 * Все входные данные наших тестов всегда соблюдают указанные параметры, дополнительные проверки не требуются
 * <p>
 * Выходные данные (ожидаются в стандартном потоке вывода)
 * <p>
 * Одно целое число, минимально возможное K. Либо 0, если в офисе нет печенек, или если Фёдор не успеет съесть все печеньки за выделенное время.
 * <p>
 * Пример 1
 * <p>
 * Ввод:
 * <p>
 * 3 6
 * 4
 * 4
 * 4
 * <p>
 * Вывод:
 * <p>
 * 2
 * <p>
 * Простой пример для ознакомления с входными и выходными данными
 * <p>
 * Пример 2
 * <p>
 * Ввод:
 * <p>
 * 3 6
 * 4
 * 4
 * 5
 * <p>
 * Вывод:
 * <p>
 * 3
 * <p>
 * Здесь похожая ситуация, но съедая по 2 печеньки, Фёдор не успеет съесть последнюю
 * <p>
 * Пример 3
 * <p>
 * Ввод:
 * <p>
 * 3 3
 * 6
 * 6
 * 8
 * <p>
 * Вывод:
 * <p>
 * 8
 * <p>
 * Граничная ситуация при N = M
 * <p>
 * <p>
 * Примечания по оформлению решения
 * <p>
 * Возможно использование только стандартных библиотек языков, установки и использование дополнительных библиотек невозможны.
 * <p>
 * При отправке решений на Java необходимо назвать исполняемый класс Main. В решении не нужно указывать пакет.
 * <p>
 * Примеры работы со стандартными потоками ввода и вывода
 * <p>
 * Для JS можно использовать readline и console.log:
 * <p>
 * const readline = require('readline').createInterface(process.stdin, process.stdout);
 * readline.on('line', (line) => {
 * // Введенная строка в переменной line, тут можно написать решение и вывести его с помощью console.log
 * ...
 * console.log(String(result));
 * readline.close();
 * }).on('close', () => process.exit(0));
 * <p>
 * <p>
 * в Python можно использовать встроенные функции input() и print():
 * <p>
 * line = input()
 * ...
 * print(result)
 * <p>
 * <p>
 * в Java можно использовать java.util.Scanner и System.out.println:
 * <p>
 * Scanner in = new Scanner(System.in);
 * String line = in.nextLine();
 * ...
 * System.out.println(result);
 * <p>
 * <p>
 * Перед отправкой решения рекомендуем запустить тесты из раздела Тестирование, они помогут поймать
 * синтаксические ошибки и ошибки выполнения.
 * <p>
 * Задача 1. Офисные печеньки
 * Условие задачи
 * Ограничение времени, с	1
 * Ограничение памяти, МБ	64
 * Общее число попыток отправки	15
 * <p>
 * Разработчик Фёдор очень любит печеньки в офисе, и он точно знает все N мест, где их можно найти, а также точное количество печенек Сn в каждом месте. Сегодня Фёдор особенно голоден, он закончил большую задачу, и решает выделить себе M часов на то, чтобы съесть все печеньки в офисе.
 * <p>
 * Фёдор рассчитал минимальное количество печенек K, которое ему нужно съедать в течение часа так, чтобы в итоге успеть съесть все печеньки в офисе за выделенное время.
 * <p>
 * В каждый час, он может посетить одно любое место с печеньками и съесть K печенек в этом месте, он потратит на это целый час, даже если в этом месте осталось меньше, чем K печенек, потому что будет обсуждать с коллегами задачи и планы. Места без печенек Фёдор может не посещать.
 * <p>
 * Коллеги, из уважения к Фёдору, никогда не трогают его любимые печеньки
 * <p>
 * Входные данные (поступают в стандартный поток ввода)
 * <p>
 * Первая строка - целые числа N и M через пробел (1≤N≤100 000, 1≤M≤200 000)
 * <p>
 * Далее N строк, на каждой из которых одно целое число Cn (0≤Cn≤10 000)
 * <p>
 * Все входные данные наших тестов всегда соблюдают указанные параметры, дополнительные проверки не требуются
 * <p>
 * Выходные данные (ожидаются в стандартном потоке вывода)
 * <p>
 * Одно целое число, минимально возможное K. Либо 0, если в офисе нет печенек, или если Фёдор не успеет съесть все печеньки за выделенное время.
 * <p>
 * Пример 1
 * <p>
 * Ввод:
 * <p>
 * 3 6
 * 4
 * 4
 * 4
 * <p>
 * Вывод:
 * <p>
 * 2
 * <p>
 * Простой пример для ознакомления с входными и выходными данными
 * <p>
 * Пример 2
 * <p>
 * Ввод:
 * <p>
 * 3 6
 * 4
 * 4
 * 5
 * <p>
 * Вывод:
 * <p>
 * 3
 * <p>
 * Здесь похожая ситуация, но съедая по 2 печеньки, Фёдор не успеет съесть последнюю
 * <p>
 * Пример 3
 * <p>
 * Ввод:
 * <p>
 * 3 3
 * 6
 * 6
 * 8
 * <p>
 * Вывод:
 * <p>
 * 8
 * <p>
 * Граничная ситуация при N = M
 * <p>
 * <p>
 * Примечания по оформлению решения
 * <p>
 * Возможно использование только стандартных библиотек языков, установки и использование дополнительных библиотек невозможны.
 * <p>
 * При отправке решений на Java необходимо назвать исполняемый класс Main. В решении не нужно указывать пакет.
 * <p>
 * Примеры работы со стандартными потоками ввода и вывода
 * <p>
 * Для JS можно использовать readline и console.log:
 * <p>
 * const readline = require('readline').createInterface(process.stdin, process.stdout);
 * readline.on('line', (line) => {
 * // Введенная строка в переменной line, тут можно написать решение и вывести его с помощью console.log
 * ...
 * console.log(String(result));
 * readline.close();
 * }).on('close', () => process.exit(0));
 * <p>
 * <p>
 * в Python можно использовать встроенные функции input() и print():
 * <p>
 * line = input()
 * ...
 * print(result)
 * <p>
 * <p>
 * в Java можно использовать java.util.Scanner и System.out.println:
 * <p>
 * Scanner in = new Scanner(System.in);
 * String line = in.nextLine();
 * ...
 * System.out.println(result);
 * <p>
 * <p>
 * Перед отправкой решения рекомендуем запустить тесты из раздела Тестирование, они помогут поймать
 * синтаксические ошибки и ошибки выполнения.
 * <p>
 * Задача 1. Офисные печеньки
 * Условие задачи
 * Ограничение времени, с	1
 * Ограничение памяти, МБ	64
 * Общее число попыток отправки	15
 * <p>
 * Разработчик Фёдор очень любит печеньки в офисе, и он точно знает все N мест, где их можно найти, а также точное количество печенек Сn в каждом месте. Сегодня Фёдор особенно голоден, он закончил большую задачу, и решает выделить себе M часов на то, чтобы съесть все печеньки в офисе.
 * <p>
 * Фёдор рассчитал минимальное количество печенек K, которое ему нужно съедать в течение часа так, чтобы в итоге успеть съесть все печеньки в офисе за выделенное время.
 * <p>
 * В каждый час, он может посетить одно любое место с печеньками и съесть K печенек в этом месте, он потратит на это целый час, даже если в этом месте осталось меньше, чем K печенек, потому что будет обсуждать с коллегами задачи и планы. Места без печенек Фёдор может не посещать.
 * <p>
 * Коллеги, из уважения к Фёдору, никогда не трогают его любимые печеньки
 * <p>
 * Входные данные (поступают в стандартный поток ввода)
 * <p>
 * Первая строка - целые числа N и M через пробел (1≤N≤100 000, 1≤M≤200 000)
 * <p>
 * Далее N строк, на каждой из которых одно целое число Cn (0≤Cn≤10 000)
 * <p>
 * Все входные данные наших тестов всегда соблюдают указанные параметры, дополнительные проверки не требуются
 * <p>
 * Выходные данные (ожидаются в стандартном потоке вывода)
 * <p>
 * Одно целое число, минимально возможное K. Либо 0, если в офисе нет печенек, или если Фёдор не успеет съесть все печеньки за выделенное время.
 * <p>
 * Пример 1
 * <p>
 * Ввод:
 * <p>
 * 3 6
 * 4
 * 4
 * 4
 * <p>
 * Вывод:
 * <p>
 * 2
 * <p>
 * Простой пример для ознакомления с входными и выходными данными
 * <p>
 * Пример 2
 * <p>
 * Ввод:
 * <p>
 * 3 6
 * 4
 * 4
 * 5
 * <p>
 * Вывод:
 * <p>
 * 3
 * <p>
 * Здесь похожая ситуация, но съедая по 2 печеньки, Фёдор не успеет съесть последнюю
 * <p>
 * Пример 3
 * <p>
 * Ввод:
 * <p>
 * 3 3
 * 6
 * 6
 * 8
 * <p>
 * Вывод:
 * <p>
 * 8
 * <p>
 * Граничная ситуация при N = M
 * <p>
 * <p>
 * Примечания по оформлению решения
 * <p>
 * Возможно использование только стандартных библиотек языков, установки и использование дополнительных библиотек невозможны.
 * <p>
 * При отправке решений на Java необходимо назвать исполняемый класс Main. В решении не нужно указывать пакет.
 * <p>
 * Примеры работы со стандартными потоками ввода и вывода
 * <p>
 * Для JS можно использовать readline и console.log:
 * <p>
 * const readline = require('readline').createInterface(process.stdin, process.stdout);
 * readline.on('line', (line) => {
 * // Введенная строка в переменной line, тут можно написать решение и вывести его с помощью console.log
 * ...
 * console.log(String(result));
 * readline.close();
 * }).on('close', () => process.exit(0));
 * <p>
 * <p>
 * в Python можно использовать встроенные функции input() и print():
 * <p>
 * line = input()
 * ...
 * print(result)
 * <p>
 * <p>
 * в Java можно использовать java.util.Scanner и System.out.println:
 * <p>
 * Scanner in = new Scanner(System.in);
 * String line = in.nextLine();
 * ...
 * System.out.println(result);
 * <p>
 * <p>
 * Перед отправкой решения рекомендуем запустить тесты из раздела Тестирование, они помогут поймать
 * синтаксические ошибки и ошибки выполнения.
 * <p>
 * Задача 1. Офисные печеньки
 * Условие задачи
 * Ограничение времени, с	1
 * Ограничение памяти, МБ	64
 * Общее число попыток отправки	15
 * <p>
 * Разработчик Фёдор очень любит печеньки в офисе, и он точно знает все N мест, где их можно найти, а также точное количество печенек Сn в каждом месте. Сегодня Фёдор особенно голоден, он закончил большую задачу, и решает выделить себе M часов на то, чтобы съесть все печеньки в офисе.
 * <p>
 * Фёдор рассчитал минимальное количество печенек K, которое ему нужно съедать в течение часа так, чтобы в итоге успеть съесть все печеньки в офисе за выделенное время.
 * <p>
 * В каждый час, он может посетить одно любое место с печеньками и съесть K печенек в этом месте, он потратит на это целый час, даже если в этом месте осталось меньше, чем K печенек, потому что будет обсуждать с коллегами задачи и планы. Места без печенек Фёдор может не посещать.
 * <p>
 * Коллеги, из уважения к Фёдору, никогда не трогают его любимые печеньки
 * <p>
 * Входные данные (поступают в стандартный поток ввода)
 * <p>
 * Первая строка - целые числа N и M через пробел (1≤N≤100 000, 1≤M≤200 000)
 * <p>
 * Далее N строк, на каждой из которых одно целое число Cn (0≤Cn≤10 000)
 * <p>
 * Все входные данные наших тестов всегда соблюдают указанные параметры, дополнительные проверки не требуются
 * <p>
 * Выходные данные (ожидаются в стандартном потоке вывода)
 * <p>
 * Одно целое число, минимально возможное K. Либо 0, если в офисе нет печенек, или если Фёдор не успеет съесть все печеньки за выделенное время.
 * <p>
 * Пример 1
 * <p>
 * Ввод:
 * <p>
 * 3 6
 * 4
 * 4
 * 4
 * <p>
 * Вывод:
 * <p>
 * 2
 * <p>
 * Простой пример для ознакомления с входными и выходными данными
 * <p>
 * Пример 2
 * <p>
 * Ввод:
 * <p>
 * 3 6
 * 4
 * 4
 * 5
 * <p>
 * Вывод:
 * <p>
 * 3
 * <p>
 * Здесь похожая ситуация, но съедая по 2 печеньки, Фёдор не успеет съесть последнюю
 * <p>
 * Пример 3
 * <p>
 * Ввод:
 * <p>
 * 3 3
 * 6
 * 6
 * 8
 * <p>
 * Вывод:
 * <p>
 * 8
 * <p>
 * Граничная ситуация при N = M
 * <p>
 * <p>
 * Примечания по оформлению решения
 * <p>
 * Возможно использование только стандартных библиотек языков, установки и использование дополнительных библиотек невозможны.
 * <p>
 * При отправке решений на Java необходимо назвать исполняемый класс Main. В решении не нужно указывать пакет.
 * <p>
 * Примеры работы со стандартными потоками ввода и вывода
 * <p>
 * Для JS можно использовать readline и console.log:
 * <p>
 * const readline = require('readline').createInterface(process.stdin, process.stdout);
 * readline.on('line', (line) => {
 * // Введенная строка в переменной line, тут можно написать решение и вывести его с помощью console.log
 * ...
 * console.log(String(result));
 * readline.close();
 * }).on('close', () => process.exit(0));
 * <p>
 * <p>
 * в Python можно использовать встроенные функции input() и print():
 * <p>
 * line = input()
 * ...
 * print(result)
 * <p>
 * <p>
 * в Java можно использовать java.util.Scanner и System.out.println:
 * <p>
 * Scanner in = new Scanner(System.in);
 * String line = in.nextLine();
 * ...
 * System.out.println(result);
 * <p>
 * <p>
 * Перед отправкой решения рекомендуем запустить тесты из раздела Тестирование, они помогут поймать
 * синтаксические ошибки и ошибки выполнения.
 * <p>
 * Задача 1. Офисные печеньки
 * Условие задачи
 * Ограничение времени, с	1
 * Ограничение памяти, МБ	64
 * Общее число попыток отправки	15
 * <p>
 * Разработчик Фёдор очень любит печеньки в офисе, и он точно знает все N мест, где их можно найти, а также точное количество печенек Сn в каждом месте. Сегодня Фёдор особенно голоден, он закончил большую задачу, и решает выделить себе M часов на то, чтобы съесть все печеньки в офисе.
 * <p>
 * Фёдор рассчитал минимальное количество печенек K, которое ему нужно съедать в течение часа так, чтобы в итоге успеть съесть все печеньки в офисе за выделенное время.
 * <p>
 * В каждый час, он может посетить одно любое место с печеньками и съесть K печенек в этом месте, он потратит на это целый час, даже если в этом месте осталось меньше, чем K печенек, потому что будет обсуждать с коллегами задачи и планы. Места без печенек Фёдор может не посещать.
 * <p>
 * Коллеги, из уважения к Фёдору, никогда не трогают его любимые печеньки
 * <p>
 * Входные данные (поступают в стандартный поток ввода)
 * <p>
 * Первая строка - целые числа N и M через пробел (1≤N≤100 000, 1≤M≤200 000)
 * <p>
 * Далее N строк, на каждой из которых одно целое число Cn (0≤Cn≤10 000)
 * <p>
 * Все входные данные наших тестов всегда соблюдают указанные параметры, дополнительные проверки не требуются
 * <p>
 * Выходные данные (ожидаются в стандартном потоке вывода)
 * <p>
 * Одно целое число, минимально возможное K. Либо 0, если в офисе нет печенек, или если Фёдор не успеет съесть все печеньки за выделенное время.
 * <p>
 * Пример 1
 * <p>
 * Ввод:
 * <p>
 * 3 6
 * 4
 * 4
 * 4
 * <p>
 * Вывод:
 * <p>
 * 2
 * <p>
 * Простой пример для ознакомления с входными и выходными данными
 * <p>
 * Пример 2
 * <p>
 * Ввод:
 * <p>
 * 3 6
 * 4
 * 4
 * 5
 * <p>
 * Вывод:
 * <p>
 * 3
 * <p>
 * Здесь похожая ситуация, но съедая по 2 печеньки, Фёдор не успеет съесть последнюю
 * <p>
 * Пример 3
 * <p>
 * Ввод:
 * <p>
 * 3 3
 * 6
 * 6
 * 8
 * <p>
 * Вывод:
 * <p>
 * 8
 * <p>
 * Граничная ситуация при N = M
 * <p>
 * <p>
 * Примечания по оформлению решения
 * <p>
 * Возможно использование только стандартных библиотек языков, установки и использование дополнительных библиотек невозможны.
 * <p>
 * При отправке решений на Java необходимо назвать исполняемый класс Main. В решении не нужно указывать пакет.
 * <p>
 * Примеры работы со стандартными потоками ввода и вывода
 * <p>
 * Для JS можно использовать readline и console.log:
 * <p>
 * const readline = require('readline').createInterface(process.stdin, process.stdout);
 * readline.on('line', (line) => {
 * // Введенная строка в переменной line, тут можно написать решение и вывести его с помощью console.log
 * ...
 * console.log(String(result));
 * readline.close();
 * }).on('close', () => process.exit(0));
 * <p>
 * <p>
 * в Python можно использовать встроенные функции input() и print():
 * <p>
 * line = input()
 * ...
 * print(result)
 * <p>
 * <p>
 * в Java можно использовать java.util.Scanner и System.out.println:
 * <p>
 * Scanner in = new Scanner(System.in);
 * String line = in.nextLine();
 * ...
 * System.out.println(result);
 * <p>
 * <p>
 * Перед отправкой решения рекомендуем запустить тесты из раздела Тестирование, они помогут поймать
 * синтаксические ошибки и ошибки выполнения.
 * <p>
 * Задача 1. Офисные печеньки
 * Условие задачи
 * Ограничение времени, с	1
 * Ограничение памяти, МБ	64
 * Общее число попыток отправки	15
 * <p>
 * Разработчик Фёдор очень любит печеньки в офисе, и он точно знает все N мест, где их можно найти, а также точное количество печенек Сn в каждом месте. Сегодня Фёдор особенно голоден, он закончил большую задачу, и решает выделить себе M часов на то, чтобы съесть все печеньки в офисе.
 * <p>
 * Фёдор рассчитал минимальное количество печенек K, которое ему нужно съедать в течение часа так, чтобы в итоге успеть съесть все печеньки в офисе за выделенное время.
 * <p>
 * В каждый час, он может посетить одно любое место с печеньками и съесть K печенек в этом месте, он потратит на это целый час, даже если в этом месте осталось меньше, чем K печенек, потому что будет обсуждать с коллегами задачи и планы. Места без печенек Фёдор может не посещать.
 * <p>
 * Коллеги, из уважения к Фёдору, никогда не трогают его любимые печеньки
 * <p>
 * Входные данные (поступают в стандартный поток ввода)
 * <p>
 * Первая строка - целые числа N и M через пробел (1≤N≤100 000, 1≤M≤200 000)
 * <p>
 * Далее N строк, на каждой из которых одно целое число Cn (0≤Cn≤10 000)
 * <p>
 * Все входные данные наших тестов всегда соблюдают указанные параметры, дополнительные проверки не требуются
 * <p>
 * Выходные данные (ожидаются в стандартном потоке вывода)
 * <p>
 * Одно целое число, минимально возможное K. Либо 0, если в офисе нет печенек, или если Фёдор не успеет съесть все печеньки за выделенное время.
 * <p>
 * Пример 1
 * <p>
 * Ввод:
 * <p>
 * 3 6
 * 4
 * 4
 * 4
 * <p>
 * Вывод:
 * <p>
 * 2
 * <p>
 * Простой пример для ознакомления с входными и выходными данными
 * <p>
 * Пример 2
 * <p>
 * Ввод:
 * <p>
 * 3 6
 * 4
 * 4
 * 5
 * <p>
 * Вывод:
 * <p>
 * 3
 * <p>
 * Здесь похожая ситуация, но съедая по 2 печеньки, Фёдор не успеет съесть последнюю
 * <p>
 * Пример 3
 * <p>
 * Ввод:
 * <p>
 * 3 3
 * 6
 * 6
 * 8
 * <p>
 * Вывод:
 * <p>
 * 8
 * <p>
 * Граничная ситуация при N = M
 * <p>
 * <p>
 * Примечания по оформлению решения
 * <p>
 * Возможно использование только стандартных библиотек языков, установки и использование дополнительных библиотек невозможны.
 * <p>
 * При отправке решений на Java необходимо назвать исполняемый класс Main. В решении не нужно указывать пакет.
 * <p>
 * Примеры работы со стандартными потоками ввода и вывода
 * <p>
 * Для JS можно использовать readline и console.log:
 * <p>
 * const readline = require('readline').createInterface(process.stdin, process.stdout);
 * readline.on('line', (line) => {
 * // Введенная строка в переменной line, тут можно написать решение и вывести его с помощью console.log
 * ...
 * console.log(String(result));
 * readline.close();
 * }).on('close', () => process.exit(0));
 * <p>
 * <p>
 * в Python можно использовать встроенные функции input() и print():
 * <p>
 * line = input()
 * ...
 * print(result)
 * <p>
 * <p>
 * в Java можно использовать java.util.Scanner и System.out.println:
 * <p>
 * Scanner in = new Scanner(System.in);
 * String line = in.nextLine();
 * ...
 * System.out.println(result);
 * <p>
 * <p>
 * Перед отправкой решения рекомендуем запустить тесты из раздела Тестирование, они помогут поймать
 * синтаксические ошибки и ошибки выполнения.
 * <p>
 * Задача 1. Офисные печеньки
 * Условие задачи
 * Ограничение времени, с	1
 * Ограничение памяти, МБ	64
 * Общее число попыток отправки	15
 * <p>
 * Разработчик Фёдор очень любит печеньки в офисе, и он точно знает все N мест, где их можно найти, а также точное количество печенек Сn в каждом месте. Сегодня Фёдор особенно голоден, он закончил большую задачу, и решает выделить себе M часов на то, чтобы съесть все печеньки в офисе.
 * <p>
 * Фёдор рассчитал минимальное количество печенек K, которое ему нужно съедать в течение часа так, чтобы в итоге успеть съесть все печеньки в офисе за выделенное время.
 * <p>
 * В каждый час, он может посетить одно любое место с печеньками и съесть K печенек в этом месте, он потратит на это целый час, даже если в этом месте осталось меньше, чем K печенек, потому что будет обсуждать с коллегами задачи и планы. Места без печенек Фёдор может не посещать.
 * <p>
 * Коллеги, из уважения к Фёдору, никогда не трогают его любимые печеньки
 * <p>
 * Входные данные (поступают в стандартный поток ввода)
 * <p>
 * Первая строка - целые числа N и M через пробел (1≤N≤100 000, 1≤M≤200 000)
 * <p>
 * Далее N строк, на каждой из которых одно целое число Cn (0≤Cn≤10 000)
 * <p>
 * Все входные данные наших тестов всегда соблюдают указанные параметры, дополнительные проверки не требуются
 * <p>
 * Выходные данные (ожидаются в стандартном потоке вывода)
 * <p>
 * Одно целое число, минимально возможное K. Либо 0, если в офисе нет печенек, или если Фёдор не успеет съесть все печеньки за выделенное время.
 * <p>
 * Пример 1
 * <p>
 * Ввод:
 * <p>
 * 3 6
 * 4
 * 4
 * 4
 * <p>
 * Вывод:
 * <p>
 * 2
 * <p>
 * Простой пример для ознакомления с входными и выходными данными
 * <p>
 * Пример 2
 * <p>
 * Ввод:
 * <p>
 * 3 6
 * 4
 * 4
 * 5
 * <p>
 * Вывод:
 * <p>
 * 3
 * <p>
 * Здесь похожая ситуация, но съедая по 2 печеньки, Фёдор не успеет съесть последнюю
 * <p>
 * Пример 3
 * <p>
 * Ввод:
 * <p>
 * 3 3
 * 6
 * 6
 * 8
 * <p>
 * Вывод:
 * <p>
 * 8
 * <p>
 * Граничная ситуация при N = M
 * <p>
 * <p>
 * Примечания по оформлению решения
 * <p>
 * Возможно использование только стандартных библиотек языков, установки и использование дополнительных библиотек невозможны.
 * <p>
 * При отправке решений на Java необходимо назвать исполняемый класс Main. В решении не нужно указывать пакет.
 * <p>
 * Примеры работы со стандартными потоками ввода и вывода
 * <p>
 * Для JS можно использовать readline и console.log:
 * <p>
 * const readline = require('readline').createInterface(process.stdin, process.stdout);
 * readline.on('line', (line) => {
 * // Введенная строка в переменной line, тут можно написать решение и вывести его с помощью console.log
 * ...
 * console.log(String(result));
 * readline.close();
 * }).on('close', () => process.exit(0));
 * <p>
 * <p>
 * в Python можно использовать встроенные функции input() и print():
 * <p>
 * line = input()
 * ...
 * print(result)
 * <p>
 * <p>
 * в Java можно использовать java.util.Scanner и System.out.println:
 * <p>
 * Scanner in = new Scanner(System.in);
 * String line = in.nextLine();
 * ...
 * System.out.println(result);
 * <p>
 * <p>
 * Перед отправкой решения рекомендуем запустить тесты из раздела Тестирование, они помогут поймать
 * синтаксические ошибки и ошибки выполнения.
 * <p>
 * Задача 1. Офисные печеньки
 * Условие задачи
 * Ограничение времени, с	1
 * Ограничение памяти, МБ	64
 * Общее число попыток отправки	15
 * <p>
 * Разработчик Фёдор очень любит печеньки в офисе, и он точно знает все N мест, где их можно найти, а также точное количество печенек Сn в каждом месте. Сегодня Фёдор особенно голоден, он закончил большую задачу, и решает выделить себе M часов на то, чтобы съесть все печеньки в офисе.
 * <p>
 * Фёдор рассчитал минимальное количество печенек K, которое ему нужно съедать в течение часа так, чтобы в итоге успеть съесть все печеньки в офисе за выделенное время.
 * <p>
 * В каждый час, он может посетить одно любое место с печеньками и съесть K печенек в этом месте, он потратит на это целый час, даже если в этом месте осталось меньше, чем K печенек, потому что будет обсуждать с коллегами задачи и планы. Места без печенек Фёдор может не посещать.
 * <p>
 * Коллеги, из уважения к Фёдору, никогда не трогают его любимые печеньки
 * <p>
 * Входные данные (поступают в стандартный поток ввода)
 * <p>
 * Первая строка - целые числа N и M через пробел (1≤N≤100 000, 1≤M≤200 000)
 * <p>
 * Далее N строк, на каждой из которых одно целое число Cn (0≤Cn≤10 000)
 * <p>
 * Все входные данные наших тестов всегда соблюдают указанные параметры, дополнительные проверки не требуются
 * <p>
 * Выходные данные (ожидаются в стандартном потоке вывода)
 * <p>
 * Одно целое число, минимально возможное K. Либо 0, если в офисе нет печенек, или если Фёдор не успеет съесть все печеньки за выделенное время.
 * <p>
 * Пример 1
 * <p>
 * Ввод:
 * <p>
 * 3 6
 * 4
 * 4
 * 4
 * <p>
 * Вывод:
 * <p>
 * 2
 * <p>
 * Простой пример для ознакомления с входными и выходными данными
 * <p>
 * Пример 2
 * <p>
 * Ввод:
 * <p>
 * 3 6
 * 4
 * 4
 * 5
 * <p>
 * Вывод:
 * <p>
 * 3
 * <p>
 * Здесь похожая ситуация, но съедая по 2 печеньки, Фёдор не успеет съесть последнюю
 * <p>
 * Пример 3
 * <p>
 * Ввод:
 * <p>
 * 3 3
 * 6
 * 6
 * 8
 * <p>
 * Вывод:
 * <p>
 * 8
 * <p>
 * Граничная ситуация при N = M
 * <p>
 * <p>
 * Примечания по оформлению решения
 * <p>
 * Возможно использование только стандартных библиотек языков, установки и использование дополнительных библиотек невозможны.
 * <p>
 * При отправке решений на Java необходимо назвать исполняемый класс Main. В решении не нужно указывать пакет.
 * <p>
 * Примеры работы со стандартными потоками ввода и вывода
 * <p>
 * Для JS можно использовать readline и console.log:
 * <p>
 * const readline = require('readline').createInterface(process.stdin, process.stdout);
 * readline.on('line', (line) => {
 * // Введенная строка в переменной line, тут можно написать решение и вывести его с помощью console.log
 * ...
 * console.log(String(result));
 * readline.close();
 * }).on('close', () => process.exit(0));
 * <p>
 * <p>
 * в Python можно использовать встроенные функции input() и print():
 * <p>
 * line = input()
 * ...
 * print(result)
 * <p>
 * <p>
 * в Java можно использовать java.util.Scanner и System.out.println:
 * <p>
 * Scanner in = new Scanner(System.in);
 * String line = in.nextLine();
 * ...
 * System.out.println(result);
 * <p>
 * <p>
 * Перед отправкой решения рекомендуем запустить тесты из раздела Тестирование, они помогут поймать
 * синтаксические ошибки и ошибки выполнения.
 * <p>
 * Задача 1. Офисные печеньки
 * Условие задачи
 * Ограничение времени, с	1
 * Ограничение памяти, МБ	64
 * Общее число попыток отправки	15
 * <p>
 * Разработчик Фёдор очень любит печеньки в офисе, и он точно знает все N мест, где их можно найти, а также точное количество печенек Сn в каждом месте. Сегодня Фёдор особенно голоден, он закончил большую задачу, и решает выделить себе M часов на то, чтобы съесть все печеньки в офисе.
 * <p>
 * Фёдор рассчитал минимальное количество печенек K, которое ему нужно съедать в течение часа так, чтобы в итоге успеть съесть все печеньки в офисе за выделенное время.
 * <p>
 * В каждый час, он может посетить одно любое место с печеньками и съесть K печенек в этом месте, он потратит на это целый час, даже если в этом месте осталось меньше, чем K печенек, потому что будет обсуждать с коллегами задачи и планы. Места без печенек Фёдор может не посещать.
 * <p>
 * Коллеги, из уважения к Фёдору, никогда не трогают его любимые печеньки
 * <p>
 * Входные данные (поступают в стандартный поток ввода)
 * <p>
 * Первая строка - целые числа N и M через пробел (1≤N≤100 000, 1≤M≤200 000)
 * <p>
 * Далее N строк, на каждой из которых одно целое число Cn (0≤Cn≤10 000)
 * <p>
 * Все входные данные наших тестов всегда соблюдают указанные параметры, дополнительные проверки не требуются
 * <p>
 * Выходные данные (ожидаются в стандартном потоке вывода)
 * <p>
 * Одно целое число, минимально возможное K. Либо 0, если в офисе нет печенек, или если Фёдор не успеет съесть все печеньки за выделенное время.
 * <p>
 * Пример 1
 * <p>
 * Ввод:
 * <p>
 * 3 6
 * 4
 * 4
 * 4
 * <p>
 * Вывод:
 * <p>
 * 2
 * <p>
 * Простой пример для ознакомления с входными и выходными данными
 * <p>
 * Пример 2
 * <p>
 * Ввод:
 * <p>
 * 3 6
 * 4
 * 4
 * 5
 * <p>
 * Вывод:
 * <p>
 * 3
 * <p>
 * Здесь похожая ситуация, но съедая по 2 печеньки, Фёдор не успеет съесть последнюю
 * <p>
 * Пример 3
 * <p>
 * Ввод:
 * <p>
 * 3 3
 * 6
 * 6
 * 8
 * <p>
 * Вывод:
 * <p>
 * 8
 * <p>
 * Граничная ситуация при N = M
 * <p>
 * <p>
 * Примечания по оформлению решения
 * <p>
 * Возможно использование только стандартных библиотек языков, установки и использование дополнительных библиотек невозможны.
 * <p>
 * При отправке решений на Java необходимо назвать исполняемый класс Main. В решении не нужно указывать пакет.
 * <p>
 * Примеры работы со стандартными потоками ввода и вывода
 * <p>
 * Для JS можно использовать readline и console.log:
 * <p>
 * const readline = require('readline').createInterface(process.stdin, process.stdout);
 * readline.on('line', (line) => {
 * // Введенная строка в переменной line, тут можно написать решение и вывести его с помощью console.log
 * ...
 * console.log(String(result));
 * readline.close();
 * }).on('close', () => process.exit(0));
 * <p>
 * <p>
 * в Python можно использовать встроенные функции input() и print():
 * <p>
 * line = input()
 * ...
 * print(result)
 * <p>
 * <p>
 * в Java можно использовать java.util.Scanner и System.out.println:
 * <p>
 * Scanner in = new Scanner(System.in);
 * String line = in.nextLine();
 * ...
 * System.out.println(result);
 * <p>
 * <p>
 * Перед отправкой решения рекомендуем запустить тесты из раздела Тестирование, они помогут поймать
 * синтаксические ошибки и ошибки выполнения.
 * <p>
 * Задача 1. Офисные печеньки
 * Условие задачи
 * Ограничение времени, с	1
 * Ограничение памяти, МБ	64
 * Общее число попыток отправки	15
 * <p>
 * Разработчик Фёдор очень любит печеньки в офисе, и он точно знает все N мест, где их можно найти, а также точное количество печенек Сn в каждом месте. Сегодня Фёдор особенно голоден, он закончил большую задачу, и решает выделить себе M часов на то, чтобы съесть все печеньки в офисе.
 * <p>
 * Фёдор рассчитал минимальное количество печенек K, которое ему нужно съедать в течение часа так, чтобы в итоге успеть съесть все печеньки в офисе за выделенное время.
 * <p>
 * В каждый час, он может посетить одно любое место с печеньками и съесть K печенек в этом месте, он потратит на это целый час, даже если в этом месте осталось меньше, чем K печенек, потому что будет обсуждать с коллегами задачи и планы. Места без печенек Фёдор может не посещать.
 * <p>
 * Коллеги, из уважения к Фёдору, никогда не трогают его любимые печеньки
 * <p>
 * Входные данные (поступают в стандартный поток ввода)
 * <p>
 * Первая строка - целые числа N и M через пробел (1≤N≤100 000, 1≤M≤200 000)
 * <p>
 * Далее N строк, на каждой из которых одно целое число Cn (0≤Cn≤10 000)
 * <p>
 * Все входные данные наших тестов всегда соблюдают указанные параметры, дополнительные проверки не требуются
 * <p>
 * Выходные данные (ожидаются в стандартном потоке вывода)
 * <p>
 * Одно целое число, минимально возможное K. Либо 0, если в офисе нет печенек, или если Фёдор не успеет съесть все печеньки за выделенное время.
 * <p>
 * Пример 1
 * <p>
 * Ввод:
 * <p>
 * 3 6
 * 4
 * 4
 * 4
 * <p>
 * Вывод:
 * <p>
 * 2
 * <p>
 * Простой пример для ознакомления с входными и выходными данными
 * <p>
 * Пример 2
 * <p>
 * Ввод:
 * <p>
 * 3 6
 * 4
 * 4
 * 5
 * <p>
 * Вывод:
 * <p>
 * 3
 * <p>
 * Здесь похожая ситуация, но съедая по 2 печеньки, Фёдор не успеет съесть последнюю
 * <p>
 * Пример 3
 * <p>
 * Ввод:
 * <p>
 * 3 3
 * 6
 * 6
 * 8
 * <p>
 * Вывод:
 * <p>
 * 8
 * <p>
 * Граничная ситуация при N = M
 * <p>
 * <p>
 * Примечания по оформлению решения
 * <p>
 * Возможно использование только стандартных библиотек языков, установки и использование дополнительных библиотек невозможны.
 * <p>
 * При отправке решений на Java необходимо назвать исполняемый класс Main. В решении не нужно указывать пакет.
 * <p>
 * Примеры работы со стандартными потоками ввода и вывода
 * <p>
 * Для JS можно использовать readline и console.log:
 * <p>
 * const readline = require('readline').createInterface(process.stdin, process.stdout);
 * readline.on('line', (line) => {
 * // Введенная строка в переменной line, тут можно написать решение и вывести его с помощью console.log
 * ...
 * console.log(String(result));
 * readline.close();
 * }).on('close', () => process.exit(0));
 * <p>
 * <p>
 * в Python можно использовать встроенные функции input() и print():
 * <p>
 * line = input()
 * ...
 * print(result)
 * <p>
 * <p>
 * в Java можно использовать java.util.Scanner и System.out.println:
 * <p>
 * Scanner in = new Scanner(System.in);
 * String line = in.nextLine();
 * ...
 * System.out.println(result);
 * <p>
 * <p>
 * Перед отправкой решения рекомендуем запустить тесты из раздела Тестирование, они помогут поймать
 * синтаксические ошибки и ошибки выполнения.
 * <p>
 * Задача 1. Офисные печеньки
 * Условие задачи
 * Ограничение времени, с	1
 * Ограничение памяти, МБ	64
 * Общее число попыток отправки	15
 * <p>
 * Разработчик Фёдор очень любит печеньки в офисе, и он точно знает все N мест, где их можно найти, а также точное количество печенек Сn в каждом месте. Сегодня Фёдор особенно голоден, он закончил большую задачу, и решает выделить себе M часов на то, чтобы съесть все печеньки в офисе.
 * <p>
 * Фёдор рассчитал минимальное количество печенек K, которое ему нужно съедать в течение часа так, чтобы в итоге успеть съесть все печеньки в офисе за выделенное время.
 * <p>
 * В каждый час, он может посетить одно любое место с печеньками и съесть K печенек в этом месте, он потратит на это целый час, даже если в этом месте осталось меньше, чем K печенек, потому что будет обсуждать с коллегами задачи и планы. Места без печенек Фёдор может не посещать.
 * <p>
 * Коллеги, из уважения к Фёдору, никогда не трогают его любимые печеньки
 * <p>
 * Входные данные (поступают в стандартный поток ввода)
 * <p>
 * Первая строка - целые числа N и M через пробел (1≤N≤100 000, 1≤M≤200 000)
 * <p>
 * Далее N строк, на каждой из которых одно целое число Cn (0≤Cn≤10 000)
 * <p>
 * Все входные данные наших тестов всегда соблюдают указанные параметры, дополнительные проверки не требуются
 * <p>
 * Выходные данные (ожидаются в стандартном потоке вывода)
 * <p>
 * Одно целое число, минимально возможное K. Либо 0, если в офисе нет печенек, или если Фёдор не успеет съесть все печеньки за выделенное время.
 * <p>
 * Пример 1
 * <p>
 * Ввод:
 * <p>
 * 3 6
 * 4
 * 4
 * 4
 * <p>
 * Вывод:
 * <p>
 * 2
 * <p>
 * Простой пример для ознакомления с входными и выходными данными
 * <p>
 * Пример 2
 * <p>
 * Ввод:
 * <p>
 * 3 6
 * 4
 * 4
 * 5
 * <p>
 * Вывод:
 * <p>
 * 3
 * <p>
 * Здесь похожая ситуация, но съедая по 2 печеньки, Фёдор не успеет съесть последнюю
 * <p>
 * Пример 3
 * <p>
 * Ввод:
 * <p>
 * 3 3
 * 6
 * 6
 * 8
 * <p>
 * Вывод:
 * <p>
 * 8
 * <p>
 * Граничная ситуация при N = M
 * <p>
 * <p>
 * Примечания по оформлению решения
 * <p>
 * Возможно использование только стандартных библиотек языков, установки и использование дополнительных библиотек невозможны.
 * <p>
 * При отправке решений на Java необходимо назвать исполняемый класс Main. В решении не нужно указывать пакет.
 * <p>
 * Примеры работы со стандартными потоками ввода и вывода
 * <p>
 * Для JS можно использовать readline и console.log:
 * <p>
 * const readline = require('readline').createInterface(process.stdin, process.stdout);
 * readline.on('line', (line) => {
 * // Введенная строка в переменной line, тут можно написать решение и вывести его с помощью console.log
 * ...
 * console.log(String(result));
 * readline.close();
 * }).on('close', () => process.exit(0));
 * <p>
 * <p>
 * в Python можно использовать встроенные функции input() и print():
 * <p>
 * line = input()
 * ...
 * print(result)
 * <p>
 * <p>
 * в Java можно использовать java.util.Scanner и System.out.println:
 * <p>
 * Scanner in = new Scanner(System.in);
 * String line = in.nextLine();
 * ...
 * System.out.println(result);
 * <p>
 * <p>
 * Перед отправкой решения рекомендуем запустить тесты из раздела Тестирование, они помогут поймать
 * синтаксические ошибки и ошибки выполнения.
 * <p>
 * Задача 1. Офисные печеньки
 * Условие задачи
 * Ограничение времени, с	1
 * Ограничение памяти, МБ	64
 * Общее число попыток отправки	15
 * <p>
 * Разработчик Фёдор очень любит печеньки в офисе, и он точно знает все N мест, где их можно найти, а также точное количество печенек Сn в каждом месте. Сегодня Фёдор особенно голоден, он закончил большую задачу, и решает выделить себе M часов на то, чтобы съесть все печеньки в офисе.
 * <p>
 * Фёдор рассчитал минимальное количество печенек K, которое ему нужно съедать в течение часа так, чтобы в итоге успеть съесть все печеньки в офисе за выделенное время.
 * <p>
 * В каждый час, он может посетить одно любое место с печеньками и съесть K печенек в этом месте, он потратит на это целый час, даже если в этом месте осталось меньше, чем K печенек, потому что будет обсуждать с коллегами задачи и планы. Места без печенек Фёдор может не посещать.
 * <p>
 * Коллеги, из уважения к Фёдору, никогда не трогают его любимые печеньки
 * <p>
 * Входные данные (поступают в стандартный поток ввода)
 * <p>
 * Первая строка - целые числа N и M через пробел (1≤N≤100 000, 1≤M≤200 000)
 * <p>
 * Далее N строк, на каждой из которых одно целое число Cn (0≤Cn≤10 000)
 * <p>
 * Все входные данные наших тестов всегда соблюдают указанные параметры, дополнительные проверки не требуются
 * <p>
 * Выходные данные (ожидаются в стандартном потоке вывода)
 * <p>
 * Одно целое число, минимально возможное K. Либо 0, если в офисе нет печенек, или если Фёдор не успеет съесть все печеньки за выделенное время.
 * <p>
 * Пример 1
 * <p>
 * Ввод:
 * <p>
 * 3 6
 * 4
 * 4
 * 4
 * <p>
 * Вывод:
 * <p>
 * 2
 * <p>
 * Простой пример для ознакомления с входными и выходными данными
 * <p>
 * Пример 2
 * <p>
 * Ввод:
 * <p>
 * 3 6
 * 4
 * 4
 * 5
 * <p>
 * Вывод:
 * <p>
 * 3
 * <p>
 * Здесь похожая ситуация, но съедая по 2 печеньки, Фёдор не успеет съесть последнюю
 * <p>
 * Пример 3
 * <p>
 * Ввод:
 * <p>
 * 3 3
 * 6
 * 6
 * 8
 * <p>
 * Вывод:
 * <p>
 * 8
 * <p>
 * Граничная ситуация при N = M
 * <p>
 * <p>
 * Примечания по оформлению решения
 * <p>
 * Возможно использование только стандартных библиотек языков, установки и использование дополнительных библиотек невозможны.
 * <p>
 * При отправке решений на Java необходимо назвать исполняемый класс Main. В решении не нужно указывать пакет.
 * <p>
 * Примеры работы со стандартными потоками ввода и вывода
 * <p>
 * Для JS можно использовать readline и console.log:
 * <p>
 * const readline = require('readline').createInterface(process.stdin, process.stdout);
 * readline.on('line', (line) => {
 * // Введенная строка в переменной line, тут можно написать решение и вывести его с помощью console.log
 * ...
 * console.log(String(result));
 * readline.close();
 * }).on('close', () => process.exit(0));
 * <p>
 * <p>
 * в Python можно использовать встроенные функции input() и print():
 * <p>
 * line = input()
 * ...
 * print(result)
 * <p>
 * <p>
 * в Java можно использовать java.util.Scanner и System.out.println:
 * <p>
 * Scanner in = new Scanner(System.in);
 * String line = in.nextLine();
 * ...
 * System.out.println(result);
 * <p>
 * <p>
 * Перед отправкой решения рекомендуем запустить тесты из раздела Тестирование, они помогут поймать
 * синтаксические ошибки и ошибки выполнения.
 * <p>
 * Задача 1. Офисные печеньки
 * Условие задачи
 * Ограничение времени, с	1
 * Ограничение памяти, МБ	64
 * Общее число попыток отправки	15
 * <p>
 * Разработчик Фёдор очень любит печеньки в офисе, и он точно знает все N мест, где их можно найти, а также точное количество печенек Сn в каждом месте. Сегодня Фёдор особенно голоден, он закончил большую задачу, и решает выделить себе M часов на то, чтобы съесть все печеньки в офисе.
 * <p>
 * Фёдор рассчитал минимальное количество печенек K, которое ему нужно съедать в течение часа так, чтобы в итоге успеть съесть все печеньки в офисе за выделенное время.
 * <p>
 * В каждый час, он может посетить одно любое место с печеньками и съесть K печенек в этом месте, он потратит на это целый час, даже если в этом месте осталось меньше, чем K печенек, потому что будет обсуждать с коллегами задачи и планы. Места без печенек Фёдор может не посещать.
 * <p>
 * Коллеги, из уважения к Фёдору, никогда не трогают его любимые печеньки
 * <p>
 * Входные данные (поступают в стандартный поток ввода)
 * <p>
 * Первая строка - целые числа N и M через пробел (1≤N≤100 000, 1≤M≤200 000)
 * <p>
 * Далее N строк, на каждой из которых одно целое число Cn (0≤Cn≤10 000)
 * <p>
 * Все входные данные наших тестов всегда соблюдают указанные параметры, дополнительные проверки не требуются
 * <p>
 * Выходные данные (ожидаются в стандартном потоке вывода)
 * <p>
 * Одно целое число, минимально возможное K. Либо 0, если в офисе нет печенек, или если Фёдор не успеет съесть все печеньки за выделенное время.
 * <p>
 * Пример 1
 * <p>
 * Ввод:
 * <p>
 * 3 6
 * 4
 * 4
 * 4
 * <p>
 * Вывод:
 * <p>
 * 2
 * <p>
 * Простой пример для ознакомления с входными и выходными данными
 * <p>
 * Пример 2
 * <p>
 * Ввод:
 * <p>
 * 3 6
 * 4
 * 4
 * 5
 * <p>
 * Вывод:
 * <p>
 * 3
 * <p>
 * Здесь похожая ситуация, но съедая по 2 печеньки, Фёдор не успеет съесть последнюю
 * <p>
 * Пример 3
 * <p>
 * Ввод:
 * <p>
 * 3 3
 * 6
 * 6
 * 8
 * <p>
 * Вывод:
 * <p>
 * 8
 * <p>
 * Граничная ситуация при N = M
 * <p>
 * <p>
 * Примечания по оформлению решения
 * <p>
 * Возможно использование только стандартных библиотек языков, установки и использование дополнительных библиотек невозможны.
 * <p>
 * При отправке решений на Java необходимо назвать исполняемый класс Main. В решении не нужно указывать пакет.
 * <p>
 * Примеры работы со стандартными потоками ввода и вывода
 * <p>
 * Для JS можно использовать readline и console.log:
 * <p>
 * const readline = require('readline').createInterface(process.stdin, process.stdout);
 * readline.on('line', (line) => {
 * // Введенная строка в переменной line, тут можно написать решение и вывести его с помощью console.log
 * ...
 * console.log(String(result));
 * readline.close();
 * }).on('close', () => process.exit(0));
 * <p>
 * <p>
 * в Python можно использовать встроенные функции input() и print():
 * <p>
 * line = input()
 * ...
 * print(result)
 * <p>
 * <p>
 * в Java можно использовать java.util.Scanner и System.out.println:
 * <p>
 * Scanner in = new Scanner(System.in);
 * String line = in.nextLine();
 * ...
 * System.out.println(result);
 * <p>
 * <p>
 * Перед отправкой решения рекомендуем запустить тесты из раздела Тестирование, они помогут поймать
 * синтаксические ошибки и ошибки выполнения.
 * <p>
 * Задача 1. Офисные печеньки
 * Условие задачи
 * Ограничение времени, с	1
 * Ограничение памяти, МБ	64
 * Общее число попыток отправки	15
 * <p>
 * Разработчик Фёдор очень любит печеньки в офисе, и он точно знает все N мест, где их можно найти, а также точное количество печенек Сn в каждом месте. Сегодня Фёдор особенно голоден, он закончил большую задачу, и решает выделить себе M часов на то, чтобы съесть все печеньки в офисе.
 * <p>
 * Фёдор рассчитал минимальное количество печенек K, которое ему нужно съедать в течение часа так, чтобы в итоге успеть съесть все печеньки в офисе за выделенное время.
 * <p>
 * В каждый час, он может посетить одно любое место с печеньками и съесть K печенек в этом месте, он потратит на это целый час, даже если в этом месте осталось меньше, чем K печенек, потому что будет обсуждать с коллегами задачи и планы. Места без печенек Фёдор может не посещать.
 * <p>
 * Коллеги, из уважения к Фёдору, никогда не трогают его любимые печеньки
 * <p>
 * Входные данные (поступают в стандартный поток ввода)
 * <p>
 * Первая строка - целые числа N и M через пробел (1≤N≤100 000, 1≤M≤200 000)
 * <p>
 * Далее N строк, на каждой из которых одно целое число Cn (0≤Cn≤10 000)
 * <p>
 * Все входные данные наших тестов всегда соблюдают указанные параметры, дополнительные проверки не требуются
 * <p>
 * Выходные данные (ожидаются в стандартном потоке вывода)
 * <p>
 * Одно целое число, минимально возможное K. Либо 0, если в офисе нет печенек, или если Фёдор не успеет съесть все печеньки за выделенное время.
 * <p>
 * Пример 1
 * <p>
 * Ввод:
 * <p>
 * 3 6
 * 4
 * 4
 * 4
 * <p>
 * Вывод:
 * <p>
 * 2
 * <p>
 * Простой пример для ознакомления с входными и выходными данными
 * <p>
 * Пример 2
 * <p>
 * Ввод:
 * <p>
 * 3 6
 * 4
 * 4
 * 5
 * <p>
 * Вывод:
 * <p>
 * 3
 * <p>
 * Здесь похожая ситуация, но съедая по 2 печеньки, Фёдор не успеет съесть последнюю
 * <p>
 * Пример 3
 * <p>
 * Ввод:
 * <p>
 * 3 3
 * 6
 * 6
 * 8
 * <p>
 * Вывод:
 * <p>
 * 8
 * <p>
 * Граничная ситуация при N = M
 * <p>
 * <p>
 * Примечания по оформлению решения
 * <p>
 * Возможно использование только стандартных библиотек языков, установки и использование дополнительных библиотек невозможны.
 * <p>
 * При отправке решений на Java необходимо назвать исполняемый класс Main. В решении не нужно указывать пакет.
 * <p>
 * Примеры работы со стандартными потоками ввода и вывода
 * <p>
 * Для JS можно использовать readline и console.log:
 * <p>
 * const readline = require('readline').createInterface(process.stdin, process.stdout);
 * readline.on('line', (line) => {
 * // Введенная строка в переменной line, тут можно написать решение и вывести его с помощью console.log
 * ...
 * console.log(String(result));
 * readline.close();
 * }).on('close', () => process.exit(0));
 * <p>
 * <p>
 * в Python можно использовать встроенные функции input() и print():
 * <p>
 * line = input()
 * ...
 * print(result)
 * <p>
 * <p>
 * в Java можно использовать java.util.Scanner и System.out.println:
 * <p>
 * Scanner in = new Scanner(System.in);
 * String line = in.nextLine();
 * ...
 * System.out.println(result);
 * <p>
 * <p>
 * Перед отправкой решения рекомендуем запустить тесты из раздела Тестирование, они помогут поймать
 * синтаксические ошибки и ошибки выполнения.
 * <p>
 * Задача 1. Офисные печеньки
 * Условие задачи
 * Ограничение времени, с	1
 * Ограничение памяти, МБ	64
 * Общее число попыток отправки	15
 * <p>
 * Разработчик Фёдор очень любит печеньки в офисе, и он точно знает все N мест, где их можно найти, а также точное количество печенек Сn в каждом месте. Сегодня Фёдор особенно голоден, он закончил большую задачу, и решает выделить себе M часов на то, чтобы съесть все печеньки в офисе.
 * <p>
 * Фёдор рассчитал минимальное количество печенек K, которое ему нужно съедать в течение часа так, чтобы в итоге успеть съесть все печеньки в офисе за выделенное время.
 * <p>
 * В каждый час, он может посетить одно любое место с печеньками и съесть K печенек в этом месте, он потратит на это целый час, даже если в этом месте осталось меньше, чем K печенек, потому что будет обсуждать с коллегами задачи и планы. Места без печенек Фёдор может не посещать.
 * <p>
 * Коллеги, из уважения к Фёдору, никогда не трогают его любимые печеньки
 * <p>
 * Входные данные (поступают в стандартный поток ввода)
 * <p>
 * Первая строка - целые числа N и M через пробел (1≤N≤100 000, 1≤M≤200 000)
 * <p>
 * Далее N строк, на каждой из которых одно целое число Cn (0≤Cn≤10 000)
 * <p>
 * Все входные данные наших тестов всегда соблюдают указанные параметры, дополнительные проверки не требуются
 * <p>
 * Выходные данные (ожидаются в стандартном потоке вывода)
 * <p>
 * Одно целое число, минимально возможное K. Либо 0, если в офисе нет печенек, или если Фёдор не успеет съесть все печеньки за выделенное время.
 * <p>
 * Пример 1
 * <p>
 * Ввод:
 * <p>
 * 3 6
 * 4
 * 4
 * 4
 * <p>
 * Вывод:
 * <p>
 * 2
 * <p>
 * Простой пример для ознакомления с входными и выходными данными
 * <p>
 * Пример 2
 * <p>
 * Ввод:
 * <p>
 * 3 6
 * 4
 * 4
 * 5
 * <p>
 * Вывод:
 * <p>
 * 3
 * <p>
 * Здесь похожая ситуация, но съедая по 2 печеньки, Фёдор не успеет съесть последнюю
 * <p>
 * Пример 3
 * <p>
 * Ввод:
 * <p>
 * 3 3
 * 6
 * 6
 * 8
 * <p>
 * Вывод:
 * <p>
 * 8
 * <p>
 * Граничная ситуация при N = M
 * <p>
 * <p>
 * Примечания по оформлению решения
 * <p>
 * Возможно использование только стандартных библиотек языков, установки и использование дополнительных библиотек невозможны.
 * <p>
 * При отправке решений на Java необходимо назвать исполняемый класс Main. В решении не нужно указывать пакет.
 * <p>
 * Примеры работы со стандартными потоками ввода и вывода
 * <p>
 * Для JS можно использовать readline и console.log:
 * <p>
 * const readline = require('readline').createInterface(process.stdin, process.stdout);
 * readline.on('line', (line) => {
 * // Введенная строка в переменной line, тут можно написать решение и вывести его с помощью console.log
 * ...
 * console.log(String(result));
 * readline.close();
 * }).on('close', () => process.exit(0));
 * <p>
 * <p>
 * в Python можно использовать встроенные функции input() и print():
 * <p>
 * line = input()
 * ...
 * print(result)
 * <p>
 * <p>
 * в Java можно использовать java.util.Scanner и System.out.println:
 * <p>
 * Scanner in = new Scanner(System.in);
 * String line = in.nextLine();
 * ...
 * System.out.println(result);
 * <p>
 * <p>
 * Перед отправкой решения рекомендуем запустить тесты из раздела Тестирование, они помогут поймать
 * синтаксические ошибки и ошибки выполнения.
 * <p>
 * Задача 1. Офисные печеньки
 * Условие задачи
 * Ограничение времени, с	1
 * Ограничение памяти, МБ	64
 * Общее число попыток отправки	15
 * <p>
 * Разработчик Фёдор очень любит печеньки в офисе, и он точно знает все N мест, где их можно найти, а также точное количество печенек Сn в каждом месте. Сегодня Фёдор особенно голоден, он закончил большую задачу, и решает выделить себе M часов на то, чтобы съесть все печеньки в офисе.
 * <p>
 * Фёдор рассчитал минимальное количество печенек K, которое ему нужно съедать в течение часа так, чтобы в итоге успеть съесть все печеньки в офисе за выделенное время.
 * <p>
 * В каждый час, он может посетить одно любое место с печеньками и съесть K печенек в этом месте, он потратит на это целый час, даже если в этом месте осталось меньше, чем K печенек, потому что будет обсуждать с коллегами задачи и планы. Места без печенек Фёдор может не посещать.
 * <p>
 * Коллеги, из уважения к Фёдору, никогда не трогают его любимые печеньки
 * <p>
 * Входные данные (поступают в стандартный поток ввода)
 * <p>
 * Первая строка - целые числа N и M через пробел (1≤N≤100 000, 1≤M≤200 000)
 * <p>
 * Далее N строк, на каждой из которых одно целое число Cn (0≤Cn≤10 000)
 * <p>
 * Все входные данные наших тестов всегда соблюдают указанные параметры, дополнительные проверки не требуются
 * <p>
 * Выходные данные (ожидаются в стандартном потоке вывода)
 * <p>
 * Одно целое число, минимально возможное K. Либо 0, если в офисе нет печенек, или если Фёдор не успеет съесть все печеньки за выделенное время.
 * <p>
 * Пример 1
 * <p>
 * Ввод:
 * <p>
 * 3 6
 * 4
 * 4
 * 4
 * <p>
 * Вывод:
 * <p>
 * 2
 * <p>
 * Простой пример для ознакомления с входными и выходными данными
 * <p>
 * Пример 2
 * <p>
 * Ввод:
 * <p>
 * 3 6
 * 4
 * 4
 * 5
 * <p>
 * Вывод:
 * <p>
 * 3
 * <p>
 * Здесь похожая ситуация, но съедая по 2 печеньки, Фёдор не успеет съесть последнюю
 * <p>
 * Пример 3
 * <p>
 * Ввод:
 * <p>
 * 3 3
 * 6
 * 6
 * 8
 * <p>
 * Вывод:
 * <p>
 * 8
 * <p>
 * Граничная ситуация при N = M
 * <p>
 * <p>
 * Примечания по оформлению решения
 * <p>
 * Возможно использование только стандартных библиотек языков, установки и использование дополнительных библиотек невозможны.
 * <p>
 * При отправке решений на Java необходимо назвать исполняемый класс Main. В решении не нужно указывать пакет.
 * <p>
 * Примеры работы со стандартными потоками ввода и вывода
 * <p>
 * Для JS можно использовать readline и console.log:
 * <p>
 * const readline = require('readline').createInterface(process.stdin, process.stdout);
 * readline.on('line', (line) => {
 * // Введенная строка в переменной line, тут можно написать решение и вывести его с помощью console.log
 * ...
 * console.log(String(result));
 * readline.close();
 * }).on('close', () => process.exit(0));
 * <p>
 * <p>
 * в Python можно использовать встроенные функции input() и print():
 * <p>
 * line = input()
 * ...
 * print(result)
 * <p>
 * <p>
 * в Java можно использовать java.util.Scanner и System.out.println:
 * <p>
 * Scanner in = new Scanner(System.in);
 * String line = in.nextLine();
 * ...
 * System.out.println(result);
 * <p>
 * <p>
 * Перед отправкой решения рекомендуем запустить тесты из раздела Тестирование, они помогут поймать
 * синтаксические ошибки и ошибки выполнения.
 * <p>
 * Задача 1. Офисные печеньки
 * Условие задачи
 * Ограничение времени, с	1
 * Ограничение памяти, МБ	64
 * Общее число попыток отправки	15
 * <p>
 * Разработчик Фёдор очень любит печеньки в офисе, и он точно знает все N мест, где их можно найти, а также точное количество печенек Сn в каждом месте. Сегодня Фёдор особенно голоден, он закончил большую задачу, и решает выделить себе M часов на то, чтобы съесть все печеньки в офисе.
 * <p>
 * Фёдор рассчитал минимальное количество печенек K, которое ему нужно съедать в течение часа так, чтобы в итоге успеть съесть все печеньки в офисе за выделенное время.
 * <p>
 * В каждый час, он может посетить одно любое место с печеньками и съесть K печенек в этом месте, он потратит на это целый час, даже если в этом месте осталось меньше, чем K печенек, потому что будет обсуждать с коллегами задачи и планы. Места без печенек Фёдор может не посещать.
 * <p>
 * Коллеги, из уважения к Фёдору, никогда не трогают его любимые печеньки
 * <p>
 * Входные данные (поступают в стандартный поток ввода)
 * <p>
 * Первая строка - целые числа N и M через пробел (1≤N≤100 000, 1≤M≤200 000)
 * <p>
 * Далее N строк, на каждой из которых одно целое число Cn (0≤Cn≤10 000)
 * <p>
 * Все входные данные наших тестов всегда соблюдают указанные параметры, дополнительные проверки не требуются
 * <p>
 * Выходные данные (ожидаются в стандартном потоке вывода)
 * <p>
 * Одно целое число, минимально возможное K. Либо 0, если в офисе нет печенек, или если Фёдор не успеет съесть все печеньки за выделенное время.
 * <p>
 * Пример 1
 * <p>
 * Ввод:
 * <p>
 * 3 6
 * 4
 * 4
 * 4
 * <p>
 * Вывод:
 * <p>
 * 2
 * <p>
 * Простой пример для ознакомления с входными и выходными данными
 * <p>
 * Пример 2
 * <p>
 * Ввод:
 * <p>
 * 3 6
 * 4
 * 4
 * 5
 * <p>
 * Вывод:
 * <p>
 * 3
 * <p>
 * Здесь похожая ситуация, но съедая по 2 печеньки, Фёдор не успеет съесть последнюю
 * <p>
 * Пример 3
 * <p>
 * Ввод:
 * <p>
 * 3 3
 * 6
 * 6
 * 8
 * <p>
 * Вывод:
 * <p>
 * 8
 * <p>
 * Граничная ситуация при N = M
 * <p>
 * <p>
 * Примечания по оформлению решения
 * <p>
 * Возможно использование только стандартных библиотек языков, установки и использование дополнительных библиотек невозможны.
 * <p>
 * При отправке решений на Java необходимо назвать исполняемый класс Main. В решении не нужно указывать пакет.
 * <p>
 * Примеры работы со стандартными потоками ввода и вывода
 * <p>
 * Для JS можно использовать readline и console.log:
 * <p>
 * const readline = require('readline').createInterface(process.stdin, process.stdout);
 * readline.on('line', (line) => {
 * // Введенная строка в переменной line, тут можно написать решение и вывести его с помощью console.log
 * ...
 * console.log(String(result));
 * readline.close();
 * }).on('close', () => process.exit(0));
 * <p>
 * <p>
 * в Python можно использовать встроенные функции input() и print():
 * <p>
 * line = input()
 * ...
 * print(result)
 * <p>
 * <p>
 * в Java можно использовать java.util.Scanner и System.out.println:
 * <p>
 * Scanner in = new Scanner(System.in);
 * String line = in.nextLine();
 * ...
 * System.out.println(result);
 * <p>
 * <p>
 * Перед отправкой решения рекомендуем запустить тесты из раздела Тестирование, они помогут поймать
 * синтаксические ошибки и ошибки выполнения.
 * <p>
 * Задача 1. Офисные печеньки
 * Условие задачи
 * Ограничение времени, с	1
 * Ограничение памяти, МБ	64
 * Общее число попыток отправки	15
 * <p>
 * Разработчик Фёдор очень любит печеньки в офисе, и он точно знает все N мест, где их можно найти, а также точное количество печенек Сn в каждом месте. Сегодня Фёдор особенно голоден, он закончил большую задачу, и решает выделить себе M часов на то, чтобы съесть все печеньки в офисе.
 * <p>
 * Фёдор рассчитал минимальное количество печенек K, которое ему нужно съедать в течение часа так, чтобы в итоге успеть съесть все печеньки в офисе за выделенное время.
 * <p>
 * В каждый час, он может посетить одно любое место с печеньками и съесть K печенек в этом месте, он потратит на это целый час, даже если в этом месте осталось меньше, чем K печенек, потому что будет обсуждать с коллегами задачи и планы. Места без печенек Фёдор может не посещать.
 * <p>
 * Коллеги, из уважения к Фёдору, никогда не трогают его любимые печеньки
 * <p>
 * Входные данные (поступают в стандартный поток ввода)
 * <p>
 * Первая строка - целые числа N и M через пробел (1≤N≤100 000, 1≤M≤200 000)
 * <p>
 * Далее N строк, на каждой из которых одно целое число Cn (0≤Cn≤10 000)
 * <p>
 * Все входные данные наших тестов всегда соблюдают указанные параметры, дополнительные проверки не требуются
 * <p>
 * Выходные данные (ожидаются в стандартном потоке вывода)
 * <p>
 * Одно целое число, минимально возможное K. Либо 0, если в офисе нет печенек, или если Фёдор не успеет съесть все печеньки за выделенное время.
 * <p>
 * Пример 1
 * <p>
 * Ввод:
 * <p>
 * 3 6
 * 4
 * 4
 * 4
 * <p>
 * Вывод:
 * <p>
 * 2
 * <p>
 * Простой пример для ознакомления с входными и выходными данными
 * <p>
 * Пример 2
 * <p>
 * Ввод:
 * <p>
 * 3 6
 * 4
 * 4
 * 5
 * <p>
 * Вывод:
 * <p>
 * 3
 * <p>
 * Здесь похожая ситуация, но съедая по 2 печеньки, Фёдор не успеет съесть последнюю
 * <p>
 * Пример 3
 * <p>
 * Ввод:
 * <p>
 * 3 3
 * 6
 * 6
 * 8
 * <p>
 * Вывод:
 * <p>
 * 8
 * <p>
 * Граничная ситуация при N = M
 * <p>
 * <p>
 * Примечания по оформлению решения
 * <p>
 * Возможно использование только стандартных библиотек языков, установки и использование дополнительных библиотек невозможны.
 * <p>
 * При отправке решений на Java необходимо назвать исполняемый класс Main. В решении не нужно указывать пакет.
 * <p>
 * Примеры работы со стандартными потоками ввода и вывода
 * <p>
 * Для JS можно использовать readline и console.log:
 * <p>
 * const readline = require('readline').createInterface(process.stdin, process.stdout);
 * readline.on('line', (line) => {
 * // Введенная строка в переменной line, тут можно написать решение и вывести его с помощью console.log
 * ...
 * console.log(String(result));
 * readline.close();
 * }).on('close', () => process.exit(0));
 * <p>
 * <p>
 * в Python можно использовать встроенные функции input() и print():
 * <p>
 * line = input()
 * ...
 * print(result)
 * <p>
 * <p>
 * в Java можно использовать java.util.Scanner и System.out.println:
 * <p>
 * Scanner in = new Scanner(System.in);
 * String line = in.nextLine();
 * ...
 * System.out.println(result);
 * <p>
 * <p>
 * Перед отправкой решения рекомендуем запустить тесты из раздела Тестирование, они помогут поймать
 * синтаксические ошибки и ошибки выполнения.
 */
/**
 * Задача 1. Офисные печеньки
 * Условие задачи
 * Ограничение времени, с	1
 * Ограничение памяти, МБ	64
 * Общее число попыток отправки	15
 * <p>
 * Разработчик Фёдор очень любит печеньки в офисе, и он точно знает все N мест, где их можно найти, а также точное количество печенек Сn в каждом месте. Сегодня Фёдор особенно голоден, он закончил большую задачу, и решает выделить себе M часов на то, чтобы съесть все печеньки в офисе.
 * <p>
 * Фёдор рассчитал минимальное количество печенек K, которое ему нужно съедать в течение часа так, чтобы в итоге успеть съесть все печеньки в офисе за выделенное время.
 * <p>
 * В каждый час, он может посетить одно любое место с печеньками и съесть K печенек в этом месте, он потратит на это целый час, даже если в этом месте осталось меньше, чем K печенек, потому что будет обсуждать с коллегами задачи и планы. Места без печенек Фёдор может не посещать.
 * <p>
 * Коллеги, из уважения к Фёдору, никогда не трогают его любимые печеньки
 * <p>
 * Входные данные (поступают в стандартный поток ввода)
 * <p>
 * Первая строка - целые числа N и M через пробел (1≤N≤100 000, 1≤M≤200 000)
 * <p>
 * Далее N строк, на каждой из которых одно целое число Cn (0≤Cn≤10 000)
 * <p>
 * Все входные данные наших тестов всегда соблюдают указанные параметры, дополнительные проверки не требуются
 * <p>
 * Выходные данные (ожидаются в стандартном потоке вывода)
 * <p>
 * Одно целое число, минимально возможное K. Либо 0, если в офисе нет печенек, или если Фёдор не успеет съесть все печеньки за выделенное время.
 * <p>
 * Пример 1
 * <p>
 * Ввод:
 * <p>
 * 3 6
 * 4
 * 4
 * 4
 * <p>
 * Вывод:
 * <p>
 * 2
 * <p>
 * Простой пример для ознакомления с входными и выходными данными
 * <p>
 * Пример 2
 * <p>
 * Ввод:
 * <p>
 * 3 6
 * 4
 * 4
 * 5
 * <p>
 * Вывод:
 * <p>
 * 3
 * <p>
 * Здесь похожая ситуация, но съедая по 2 печеньки, Фёдор не успеет съесть последнюю
 * <p>
 * Пример 3
 * <p>
 * Ввод:
 * <p>
 * 3 3
 * 6
 * 6
 * 8
 * <p>
 * Вывод:
 * <p>
 * 8
 * <p>
 * Граничная ситуация при N = M
 * <p>
 * <p>
 * Примечания по оформлению решения
 * <p>
 * Возможно использование только стандартных библиотек языков, установки и использование дополнительных библиотек невозможны.
 * <p>
 * При отправке решений на Java необходимо назвать исполняемый класс Main. В решении не нужно указывать пакет.
 * <p>
 * Примеры работы со стандартными потоками ввода и вывода
 * <p>
 * Для JS можно использовать readline и console.log:
 * <p>
 * const readline = require('readline').createInterface(process.stdin, process.stdout);
 * readline.on('line', (line) => {
 * // Введенная строка в переменной line, тут можно написать решение и вывести его с помощью console.log
 * ...
 * console.log(String(result));
 * readline.close();
 * }).on('close', () => process.exit(0));
 * <p>
 * <p>
 * в Python можно использовать встроенные функции input() и print():
 * <p>
 * line = input()
 * ...
 * print(result)
 * <p>
 * <p>
 * в Java можно использовать java.util.Scanner и System.out.println:
 * <p>
 * Scanner in = new Scanner(System.in);
 * String line = in.nextLine();
 * ...
 * System.out.println(result);
 * <p>
 * <p>
 * Перед отправкой решения рекомендуем запустить тесты из раздела Тестирование, они помогут поймать
 * синтаксические ошибки и ошибки выполнения.
 */