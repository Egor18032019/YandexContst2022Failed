import java.util.Scanner;

public class Coins {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int t = scanner.nextInt();

        for (int i = 0; i < t; i++) {
            int n = scanner.nextInt();
            int m = scanner.nextInt();
            int k = scanner.nextInt();

            int[] leftCoins = new int[n];
            int[] rightCoins = new int[m];

            for (int j = 0; j < n; j++) {
                leftCoins[j] = scanner.nextInt();
            }

            for (int j = 0; j < m; j++) {
                rightCoins[j] = scanner.nextInt();
            }

            int count = 0;
            for (int j = 0; j < n; j++) {
                for (int l = 0; l < m; l++) {
                    if (leftCoins[j] + rightCoins[l] <= k) {
                        count++;
                    }
                }
            }

            System.out.println(count);
        }
    }
}
/*
Рудольф собирается в гости к Бернарду, доехать до него он решил на метро. Билет можно купить в автомате, который принимает ровно две монеты, сумма которых не превышает k

.

У Рудольфа есть два кармана с монетами. В левом кармане лежат n
монет номиналов b1,b2,…,bn. В правом кармане лежат m монет номиналов c1,c2,…,cm

. Для оплаты он хочет выбрать ровно одну монету из левого кармана и ровно одну монету из правого кармана (суммарно две монеты).

Помогите Рудольфу узнать, сколько существует способов выбрать такие индексы f
и s, что bf+cs≤k

.
Входные данные

Первая строка содержит одно целое число t
(1≤t≤100

) — количество наборов входных данных. Далее следуют описания наборов.

Первая строка каждого набора данных содержит три натуральных числа n
, m и k (1≤n,m≤100,1≤k≤2000

) — количество монет в левом и правом карманах и максимальная сумма двух монет для оплаты билета в кассе, соответственно.

Вторая строка каждого набора содержит n
целых чисел bi (1≤bi≤1000

) — номиналы монет в левом кармане.

Третья строка каждого набора содержит m
целых чисел ci (1≤ci≤1000

) — номиналы монет в правом кармане.
Выходные данные

Для каждого набора входных данных выведите одно целое число — количество способов, которыми Рудольф может выбрать две монеты, доставая по одной из каждого кармана, чтобы сумма монет не превышала k

.
Пример
Входные данные
Скопировать

4
4 4 8
1 5 10 14
2 1 8 1
2 3 4
4 8
1 2 3
4 2 7
1 1 1 1
2 7
3 4 2000
1 1 1
1 1 1 1

Выходные данные
Скопировать

6
0
4
12

Примечание

Обратите внимание, в парах указаны индексы монет в массиве, а не их номиналы.

В первом наборе Рудольф может выбрать следующие пары монет: [1,1],[1,2],[1,4],[2,1],[2,2],[2,4]

.

Во втором наборе Рудольф не может выбрать из двух карманов по одной монете ни одним способом, поскольку сумма любых двух элементов из первого и второго массивов будет превышать значение k=4

.

В третьем наборе Рудольф может выбрать: [1,1],[2,1],[3,1],[4,1]

.

В четвертом наборе Рудольф может выбрать любую монету из левого кармана и любую монету из правого кармана.


 */